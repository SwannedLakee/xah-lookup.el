#+TITLE: Literate Emacs configuration
#+AUTHOR: Timm Lichte
#+FILETAGS: emacs
#+STARTUP: indent
#+STARTUP: hideblocks content

* Good examples

- http://ivanmalison.github.io/dotfiles/
- https://github.com/novoid/dot-emacs/blob/master/config.org 
- http://www.coli.uni-saarland.de/~slemaguer/emacs/main.html

* General appearence

** Toolbar

Don't show toolbar:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
#+END_SRC

** Start-up

*** dashboard

#+BEGIN_SRC emacs-lisp
(use-package dashboard
	:ensure t
	:diminish dashboard-mode
	:config
	(setq
	 dashboard-banner-logo-title (emacs-version)
	 dashboard-startup-banner 'logo
	 dashboard-items '((recents  . 10)
										 (bookmarks . 10)
										 (projects . 5)
										 )
	 )

	(add-to-list 'dashboard-item-generators  '(custom-settings . dashboard-insert-custom-settings))
	(add-to-list 'dashboard-items '(custom-settings) t)

	(define-key dashboard-mode-map (kbd "<up>") (lambda () (interactive)(widget-forward -1)))
	(define-key dashboard-mode-map (kbd "<down>") (lambda () (interactive)(widget-forward 1)))

	(dashboard-setup-startup-hook)
	)
#+END_SRC

Custom settings (https://www.gnu.org/software/emacs/manual/html_mono/widget.html):

#+BEGIN_SRC emacs-lisp
(defun dashboard-insert-custom-settings (&rest ignore)
	(interactive)
  (widget-insert "Custom settings:\n\t\t")
	(widget-create 'checkbox
								 :notify (lambda (&rest ignore)
													 (if (bound-and-true-p cua-mode)
															 (progn (cua-mode nil)
																			(customize-save-variable 'cua-mode nil))
														 (cua-mode t)
														 (customize-save-variable 'cua-mode t)
														 ))
								 (bound-and-true-p cua-mode))
	(widget-insert " Use CUA-mode?"))
#+END_SRC

** Signals

No beep:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

** Syntax highlighting

Brackets:
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Apply syntax highlighting to all buffers:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

*** highlight-symbol

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :config
  (setq highlight-symbol-idle-delay 0.2)
  (add-hook 'highlight-symbol-mode-hook
            (function
             (lambda () (highlight-symbol-nav-mode +1)))))
#+END_SRC

** Lines

Highlight line of cursor:
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Soft-wrap lines:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Line numbers:
#+BEGIN_SRC emacs-lisp
;; (global-linum-mode t)
;; (setq linum-format " %3d ")
#+END_SRC

*** linum-relative

#+BEGIN_SRC emacs-lisp
(use-package linum-relative
	:ensure t
)
#+END_SRC

** Cursor

Cursor blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 1)										; blink
(setq blink-cursor-blinks 0)						; blink forever
#+END_SRC

Stretch cursor:
#+BEGIN_SRC emacs-lisp
(setq  x-stretch-cursor t)
#+END_SRC

** Theme

Add local themes directory to search space (just in case):

#+BEGIN_SRC emacs-lisp
(setq themes-dir
      (expand-file-name "themes" user-emacs-directory))
(add-to-list 'custom-theme-load-path themes-dir)
#+END_SRC

*** monokai-theme

The monokai theme is one of my favourites:

#+BEGIN_SRC emacs-lisp
(use-package monokai-theme
	:ensure t
	:config
	(load-theme 'monokai t)
	
	;; font size of org-mode headers 
	(setq monokai-height-minus-1 1.0
        monokai-height-plus-1 1.0
        monokai-height-plus-2 1.1
        monokai-height-plus-3 1.25
        monokai-height-plus-4 1.5)
)
#+END_SRC

- [ ] Yet I don't like how regions are highlighted:

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
 'monokai
 `(region ((t (:inherit highlight :background "#FFB269" :foreground ,monokai-background))))
 )
#+END_SRC

** Mode line and window labels

Mode line:
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
	:ensure t
	:init
	;; (setq sml/theme 'dark)
	(setq sml/no-confirm-load-theme t)
	:config
	(sml/setup)
	)
#+END_SRC

Show file path in window title:
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '(buffer-file-name "%b - %f" ; File buffer
        (dired-directory dired-directory ; Dired buffer
         (revert-buffer-function "%b" ; Buffer Menu
																 ("%b - Dir: " default-directory))))) ; Plain buffer
#+END_SRC

Show date and time:
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(display-time-mode +1)
#+END_SRC

Fringe style:
#+BEGIN_SRC emacs-lisp
;; (set-face-attribute 'fringe nil :background "#3F3F3F" :foreground "#3F3F3F")
#+END_SRC

** Distraction-free mode

*** writeroom-mode

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
	:ensure t
	:bind
	(:map writeroom-mode-map
				("C-M-<" . writeroom-decrease-width)
				("C-M->" . writeroom-increase-width)
				("C-M-=" . writeroom-adjust-width)
				("C-<f10>" . writeroom-toggle-mode-line)
				)
	)
(global-set-key (kbd "<f10>") 'writeroom-mode)
#+END_SRC

** Font 

Toggle proportional mode when appropriate.
Inspired by https://ogbe.net/blog/toggle-serif.html
#+BEGIN_SRC emacs-lisp
(defvar font-preserve-default-list nil
  "A list holding the faces that preserve the default family and
  height when TOGGLE-SERIF is used.")
(setq font-preserve-default-list
      '(;; LaTeX markup
        font-latex-math-face
        font-latex-sedate-face
        font-latex-warning-face
        ;; org markup
        org-latex-and-related
        org-meta-line
        org-verbatim
        org-block-begin-line
        ;; syntax highlighting using font-lock
        font-lock-builtin-face
        font-lock-comment-delimiter-face
        font-lock-comment-face
        font-lock-constant-face
        font-lock-doc-face
        font-lock-function-name-face
        font-lock-keyword-face
        font-lock-negation-char-face
        font-lock-preprocessor-face
        font-lock-regexp-grouping-backslash
        font-lock-regexp-grouping-construct
        font-lock-string-face
        font-lock-type-face
        font-lock-variable-name-face
        font-lock-warning-face))
(defun toggle-proportional ()
  "Change the default face of the current buffer to use a proportional family."
  (interactive)
  (when (display-graphic-p)  ;; this is only for graphical emacs
    ;; the serif font familiy and height, save the default attributes
    (let ((proportional-fam "Segoe UI")
          (proportional-height 125)
          (default-fam (face-attribute 'default :family))
          (default-height (face-attribute 'default :height)))
      (if (not (bound-and-true-p default-cookie))
          (progn (make-local-variable 'default-cookie)
                 (make-local-variable 'preserve-default-cookies-list)
                 (setq preserve-default-cookies-list nil)
                 ;; remap default face to serif
                 (setq default-cookie
                       (face-remap-add-relative
                        'default :family proportional-fam :height proportional-height))
                 ;; keep previously defined monospace fonts the same
                 (dolist (face font-preserve-default-list)
                   (add-to-list 'preserve-default-cookies-list
                                (face-remap-add-relative
                                 face :family default-fam :height default-height)))
                 (message "Turned on proportional font."))
        ;; undo changes
        (progn (face-remap-remove-relative default-cookie)
               (dolist (cookie preserve-default-cookies-list)
                 (face-remap-remove-relative cookie))
               (setq default-cookie nil)
               (setq preserve-default-cookies-list nil)
               (message "Restored default fonts."))))))
#+END_SRC

Replace LaTeX commands by UTF8 symbols:
#+BEGIN_SRC emacs-lisp
;; (use-package latex-pretty-symbols
;; 	:ensure t)
#+END_SRC

** Overlays

#+BEGIN_SRC emacs-lisp
(use-package ov
  :ensure t)
#+END_SRC

* Minibuffer

Shorten yes/no answers to y/n:
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** ido, ivy

*** ido

#+BEGIN_SRC emacs-lisp
;; ;; ido improves buffer switching experience
;; (ido-mode 1)
;; (ido-everywhere 1)
;; ;; add vertical mode to ido
;; (use-package ido-vertical-mode	
;; 	:ensure t
;; 	:config (ido-vertical-mode 1)	)
;; ;; add grid mode
;; (use-package ido-grid-mode
;; 	:ensure t
;; 	:config (ido-grid-mode 1))												
;; ;; add flx to ido 
;; (use-package flx-ido
;; 	:ensure t
;; 	:config 
;; 	(flx-ido-mode 1)
;; 	;; disable ido faces to see flx highlights.
;; 	(setq ido-enable-flex-matching t)
;; 	(setq ido-use-faces nil))
#+END_SRC

*** Recent files

#+BEGIN_SRC emacs-lisp
;; ;; recent files
;; (require 'recentf)
;; (recentf-mode 1)
;; ; 50 files ought to be enough.
;; (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
;; (setq recentf-max-saved-items 50)
;; (defun ido-recentf-open ()
;; 	"Use `ido-completing-read' to \\[find-file] a recent file"
;; 	(interactive)
;; 	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
;; 			(message "Opening file...")
;; 		(message "Aborting")))

#+END_SRC

*** ivy, counsel

#+BEGIN_SRC emacs-lisp
;; ;; counsel adds fuzzy search to command completion 
;; (use-package counsel
;; 	:ensure t
;; 	:config
;; 	(setq ivy-display-style 'fancy)
;; 	(setq ivy-re-builders-alist ; use flx
;; 				'((t . ivy--regex-fuzzy)))
;; 	(setq ivy-initial-inputs-alist nil) ; omit ^
;; 	(setq ivy-wrap t) ;; cycle through results
;; 	:bind
;; 	("M-x" . counsel-M-x)
;; 	("C-ß" . ivy-imenu-anywhere) ; ivy + imenu
;; 	)
#+END_SRC

*** COMMENT swiper

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
	:config
	(setq ivy-wrap t)
  :bind
  (("C-s" . swiper)
	 :map swiper-map
	 ("M-n" . ivy-next-history-element)
	 ("M-p" . ivy-previous-history-element))
	)
#+END_SRC

*** smex

Smex helps to remember often used commands; used by ido and counsel
#+BEGIN_SRC emacs-lisp
;; (use-package smex
;; 	:ensure t)
#+END_SRC

** imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
	:ensure t)
(use-package imenu-list
	:ensure t
	:bind
	("C-?" . imenu-list)
	:init
	(setq imenu-list-focus-after-activation t)
	(setq imenu-list-after-jump-hook t)
	;; (setq imenu-list-auto-resize t)
	(setq imenu-list-position (quote left))
	(setq imenu-list-size 30)
	:config
	(add-hook 'text-mode-hook 'imenu-list-minor-mode)
	(add-hook 'prog-mode-hook 'imenu-list-minor-mode)
	)
(add-hook 'imenu-list-minor-mode-hook (lambda () (toggle-truncate-lines))) ; FIXME
(setq org-imenu-depth 4)
#+END_SRC

** helm

#+BEGIN_SRC emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 100)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01		; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t		 ; do not display invisible candidates
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t
					helm-mode-fuzzy-match t 			; global fuzzy match
					helm-buffers-fuzzy-matching t
					helm-recentf-fuzzy-match t
					helm-M-x-fuzzy-match t
          helm-follow-mode-persistent t	; follow candidate in buffer (with C-up/C-down)
					helm-imenu-fuzzy-match t
					helm-completion-in-region-fuzzy-match t
					helm-apropos-fuzzy-match t
					helm-autoresize-mode 1 				; re-size the completion window based on number of candidates
					helm-adaptive-mode t					; show commonly used commands first
					)
		(setq bibtex-completion-bibliography user-bibliography-file
					bibtex-completion-library-path user-bibliography-pdf-dir ; directory of PDFs
					;; bibtex-completion-notes-path "~/bibliography/helm-bibtex-notes"
					)
		
		;; helm-mini
		(setq helm-mini-default-sources
					'(helm-source-buffers-list
						helm-source-bookmarks
						helm-source-recentf
						helm-source-buffer-not-found)) 

    (helm-mode)

		;; ;; http://emacs.stackexchange.com/a/7896/12336
		;; ;; <return> opens directory in helm-find-files, not dired
		;; (defun fu/helm-find-files-navigate-forward (orig-fun &rest args)
		;; 	(if (file-directory-p (helm-get-selection))
		;; 			(apply orig-fun args)
		;; 		(helm-maybe-exit-minibuffer)))
		;; (advice-add 'helm-execute-persistent-action :around #'fu/helm-find-files-navigate-forward)
		;; (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
		
    ;; http://emacs.stackexchange.com/a/7896/12336
		;; <backspace> before backslash lets helm-find-files  move one directory up
		(defun fu/helm-find-files-navigate-back (orig-fun &rest args)
			(if (= (length helm-pattern) (length (helm-find-files-initial-input)))
					(helm-find-files-up-one-level 1)
				(apply orig-fun args)))
		(advice-add 'helm-ff-delete-char-backward :around #'fu/helm-find-files-navigate-back)

		;; https://redd.it/3f55nm
		;; remove . and .. from helm-find-files
		(advice-add 'helm-ff-filter-candidate-one-by-one
								:around (lambda (fcn file)
													(unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
														(funcall fcn file))))

		)
  :bind (("M-y" . helm-mini)
				 ("C-x C-r" . helm-recentf)
         ("C-h a" . helm-apropos)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
				 ("C-x C-f" . helm-find-files)
         ("C-x C-y" . helm-show-kill-ring)
         ("C-x y" . helm-show-kill-ring)
         ("C-x t" . helm-etags-select)
				 ("C-x C-t" . helm-etags-select)
         ("C-x SPC" . helm-all-mark-rings)
         ("C-x C-SPC" . helm-all-mark-rings)				 
         ("M-x" . helm-M-x)
         ("C-s" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ("C-x c y" . helm-yas-complete)
         ("C-x c Y" . helm-yas-create-snippet-on-region)
         ("C-x c SPC" . helm-all-mark-rings)
				 ("C-ß" . helm-imenu)
				 ("C-S-?" . helm-imenu-anywhere)
				 )
)
(ido-mode -1)														; turn off ido mode, just in case

;; helm-flx: improves fuzzy matching
(use-package helm-flx
	:ensure t
	:after helm
	:config
	(helm-flx-mode +1))
;; helm-fuzzier: improves fuzzy matching even more by taking more candidates into account
(use-package helm-fuzzier
	:ensure t
	:after helm
	:config
	(helm-fuzzier-mode +1))

;; list active key bindings 
(use-package helm-descbinds
	:ensure t
  :bind ("C-h b" . helm-descbinds))
#+end_src

*** org-mode

Complete tags with helm when using =org-set-tags=:

#+BEGIN_SRC emacs-lisp
;; (load-library "helm-org-tag-completion")
#+END_SRC

*** helm-swoop

#+begin_src emacs-lisp
(use-package helm-swoop
	:ensure t
	:config
	;; Move up and down like isearch
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

	;; From helm-swoop to helm-multi-swoop-all
	(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

	;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
	(define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	
	;; If nil, you can slightly boost invoke speed in exchange for text color
	(setq helm-swoop-speed-or-color t)
	
	;; Optional face for line numbers
	;; Face name is `helm-swoop-line-number-face`
	(setq helm-swoop-use-line-number-face t)

	;; If you prefer fuzzy matching (seems to be already activated)
	;; (setq helm-swoop-use-fuzzy-match t)

	;; Do not call helm-swoop with symbol or word at point
	(setq helm-swoop-pre-input-function
				(lambda () nil))

  :bind ("C-c /" . helm-swoop))
#+END_SRC

*** swiper-helm 

- [ ] Error: "swiper-helm: Cannot open load file: No such file or directory, helm-match-plugin"

#+BEGIN_SRC emacs-lisp
(use-package swiper-helm
  :ensure t
  :bind ("C-s" . swiper-helm))
#+END_SRC

*** helm-dash

=helm-dash= depends on =sqlite3= which you probably have to install manually:
http://sqlite.org/download.html

#+BEGIN_SRC emacs-lisp
(use-package helm-dash
	:ensure t
	:init
	(setq helm-dash-common-docsets			; active in all buffers
				'())
	(setq helm-dash-browser-func 'eww)		; use internal web browser
	(when (eq system-type 'windows-nt)
		(setq helm-dash-docsets-path (expand-file-name (concat wemacs-dir "/docsets")))) ; FIXME: under windows, helm-dash does not install docsets here but in ~/AppData/... Because of missing tar command?
	(add-hook 'latex-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
	(add-hook 'TeX-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
	(add-hook 'emacs-lisp-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Emacs Lisp"))))
	(add-hook 'js2-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("JavaScript"))))
	(add-hook 'org-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Org_Mode"))))
	(add-hook 'plantuml-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("PlantUML"))))
	(add-hook 'sh-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Bash"))))
	(add-hook 'perl-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Perl"))))
	(add-hook 'python-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Python 3" "SciPy" "NumPy"))))
	:bind
	(("C-h d" . helm-dash))
	)
#+END_SRC

*** COMMENT helm-gtags

I don't use it right now.

#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :ensure t
  :config
  (setq helm-gtags-path-style 'absolute)
  (progn
    ;; keys
    (define-key helm-gtags-mode-map (kbd "C-c f") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-t") 'helm-gtags-find-tag)
    (define-key helm-gtags-mode-map (kbd "M-r") 'helm-gtags-find-rtag)
    (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-find-symbol)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
		(define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack))
	(add-hook 'prog-mode-hook 'helm-gtags-mode))
#+END_SRC

*** COMMENT helm-tramp

Does not work under windows so far. Therefore I commented this out:

#+BEGIN_SRC emacs-lisp
(use-package helm-tramp
	:ensure t)
#+END_SRC

*** dictcc

#+BEGIN_SRC emacs-lisp
(use-package dictcc
	:ensure t
	:bind
	(("C-0" . dictcc))
)
#+END_SRC

Call dictcc with word under cursor or marked region:
#+BEGIN_SRC emacs-lisp
(defun tl/dictcc-at-point ()
  (interactive)
	(if (use-region-p)
			(dictcc (concat "\"" (filter-buffer-substring (region-beginning) (region-end)) "\""))
		(if (word-at-point)
				(dictcc (word-at-point))
      (call-interactively 'dictcc))
		))
(global-set-key (kbd "C-0") 'tl/dictcc-at-point)
#+END_SRC

*** helm-org-rifle 

Quick, comprehensive search on org-mode files.

#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
	:ensure t
  :config
	(define-key helm-org-rifle-map (kbd "<left>") 'backward-char) ; instead of helm-previous-source
	(define-key helm-org-rifle-map (kbd "<right>") 'forward-char) ; instead of helm-next-source
	(define-key helm-org-rifle-map (kbd "C-n") 'helm-next-source)
	(define-key helm-org-rifle-map (kbd "C-p") 'helm-previous-source)
	(setq helm-org-rifle-show-path t)
)
#+END_SRC

*** Key bindings

#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "C-n") 'helm-next-source)
(define-key helm-map (kbd "C-p") 'helm-previous-source)
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; complete with <tab> (default is <ret>)
(define-key helm-map (kbd "C-z") 'helm-select-action) ; show actions (default is <tab>)
(define-key helm-map (kbd "<left>") 'backward-char) ; instead of C-f
(define-key helm-map (kbd "<right>") 'forward-char) ; instead of C-b
(define-key helm-map (kbd "M-<left>") 'previous-history-element)
(define-key helm-map (kbd "M-<right>") 'next-history-element)
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
(use-package which-key
	:ensure t
	:config
	(which-key-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; M-x in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-x") 'abort-recursive-edit)))

;; M-y in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-y") 'abort-recursive-edit)))

;; C-ß in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-ß") 'abort-recursive-edit)))

;; C-s in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-s") 'abort-recursive-edit)))

;; (global-set-key (kbd "C-x C-b") 'switch-to-buffer) ; instead of 'list-buffers (see helm)
;; (global-set-key (kbd "C-x b") 'ibuffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer)  
#+END_SRC

* Major modes

** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode										; for improved html support
	:ensure t
	:mode
	("\\.phtml\\'" . web-mode)
	("\\.tpl\\'" . web-mode)
	("\\.php\\'" . web-mode)
	("\\.[agj]sp\\'" . web-mode)
	("\\.as[cp]x\\'" . web-mode)
	("\\.erb\\'" . web-mode)
	("\\.mustache\\'" . web-mode)
	("\\.djhtml\\'" . web-mode)
	("\\.html?\\'" . web-mode)
	("\\.xml\\'" . web-mode)
	("\\.css\\'" . web-mode)
	("\\.svg\\'" . web-mode)
	:config
	;; highlight enclosing tags of the element under cursor
  (setq web-mode-enable-current-element-highlight t)
  ;; colorize CSS
	(setq web-mode-enable-css-colorization t)
)
#+END_SRC

** Graphviz/dot

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t
	:mode "\\.dot\\'")
#+END_SRC

** TODO Gnuplot

- [ ] compiling Gnuplot crashes Emacs

#+BEGIN_SRC emacs-lisp
;; (use-package gnuplot
;; 	:ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gnuplot-mode
	:ensure t)
#+END_SRC

** COMMENT CoNNLL-U

#+BEGIN_SRC emacs-lisp
(use-package conllu-mode
	:ensure t
	:config
	(add-to-list 'auto-mode-alist '("\\.conllu\\'" . conllu-mode))
)
#+END_SRC

** Python

*** elpy

Prerequisites as for Python:
#+BEGIN_SRC bash
	sudo pip install jedi flake8 importmagic autopep8 # Elpy's recommendation
	sudo pip install pylint virtualenv epc # Zamansky's recommendation
#+END_SRC

#+BEGIN_SRC emacs-lisp
	(use-package elpy
		:ensure t
		:defer 2
		:config
		(progn
			;; Use Flycheck instead of Flymake
			(when (require 'flycheck nil t)
				(remove-hook 'elpy-modules 'elpy-module-flymake)
				(remove-hook 'elpy-modules 'elpy-module-yasnippet)
				(remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
				(add-hook 'elpy-mode-hook 'flycheck-mode))
			(elpy-enable)
			(define-key python-mode-map (kbd "C-h f") 'python-eldoc-at-point)
			;; highlight-indentation is ugly
			(add-hook 'elpy-mode-hook '(lambda () (highlight-indentation-mode -1)))
			;; jedi is great
			(setq elpy-rpc-backend "jedi")))
#+END_SRC

*** company-jedi

#+BEGIN_SRC emacs-lisp
;; Use Company for auto-completion interface.
(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi))

(use-package company-jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'my/python-mode-hook))
#+END_SRC

*** ein (Jupyter noteboook)

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t
	:config
	(setq ein:completion-backend 'ein:use-ac-jedi-backend))
#+END_SRC

** PlantUML

Depends on plantuml.jar and Gaphviz (http://www.graphviz.org).

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :ensure t
  :mode ("\\.plu\\'" "\\.puml\\'") 
  :init
	(when (eq system-type 'windows-nt)
		(setq org-plantuml-jar-path
					(expand-file-name "C:/ProgramData/chocolatey/lib/plantuml/tools/plantuml.jar"))
		(setq plantuml-jar-path
					(expand-file-name "C:/ProgramData/chocolatey/lib/plantuml/tools/plantuml.jar"))))
#+END_SRC

** dired

The following prevents Emacs from throwing =Symbol's value as variable is void: dired-mode-map=: 

#+BEGIN_SRC emacs-lisp
(require 'dired)
#+END_SRC

*** General settings

Tips:  http://ergoemacs.org/emacs/emacs_dired_tips.html

Open new buffer when opening a file/directory, if necessary: 
#+BEGIN_SRC emacs-lisp
;; (define-key dired-mode-map (kbd "<return>") 'dired-find-alternate-file) ; was dired-advertised-find-file

;; (define-key dired-mode-map (kbd "<backspace>") (lambda () (interactive) (find-alternate-file ".."))) ; find-alternate-file forgets the cursor position of the left dired buffer
;; (define-key dired-mode-map (kbd "<left>") (lambda () (interactive) (find-alternate-file "..")))

(define-key dired-mode-map (kbd "<left>") (lambda () (interactive) (diredp-up-directory)))
(define-key dired-mode-map (kbd "<backspace>") (lambda () (interactive) (diredp-up-directory)))
#+END_SRC

View file and return to dired with q:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<tab>") 'dired-view-file)
(define-key dired-mode-map (kbd "<right>") 'dired-view-file)
(add-hook 'view-mode-hook
  (lambda ()
    (define-key view-mode-map (kbd "<left>") 'View-quit)
		(define-key view-mode-map (kbd "<right>") 'View-exit-and-edit)
    ))
#+END_SRC

Copy/move into other dired buffer:
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

Show details of files and directories:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook
          (lambda () (dired-hide-details-mode -1)))
#+END_SRC

Don't break lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-initial-position-hook '(lambda () (setq truncate-lines t)))
;; (add-hook 'dired-mode-hook (lambda () (setq truncate-lines t)))
#+END_SRC

Order directories first (only windows?):
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-dirs-first t)
#+END_SRC

Ignore case when sorting:
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-ignore-case t)
#+END_SRC

Other settings: http://oremacs.com/2015/01/13/dired-options/
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-laGh1v --group-directories-first") ; --group-directories-first is only supported by recent versions of ls.
#+END_SRC

Specify ls program: https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Dired-ls.html
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t)	; use external ls
;; (setq insert-directory-program "c:/tools/cygwin/bin/ls") ; path to ls program
#+END_SRC

Chose Windows drives:
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
	(define-key dired-mode-map (kbd "\\") 'diredp-w32-drives))
#+END_SRC

Move to trash can (recycle bin under windows) when deleting:
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

*** Mark/Unmark 

Use shift-up and shift-down in the usual way.
See http://emacs.stackexchange.com/a/30890/12336

#+BEGIN_SRC emacs-lisp
(defun my-dired-toggle (arg)
  (save-restriction
    (narrow-to-region (point-at-bol) (point-at-eol))
    (dired-toggle-marks))
	(dired-previous-line arg))

(defun my-dired-mark-up ()
  (interactive)
  (my-dired-toggle 1))

(defun my-dired-mark-down ()
  (interactive)
  (my-dired-toggle -1))

(define-key dired-mode-map (kbd "<S-up>") 'my-dired-mark-up)
(define-key dired-mode-map (kbd "<S-down>") 'my-dired-mark-down)
#+END_SRC

*** TODO COMMENT Open binary files in external programm

#+BEGIN_SRC
advice(dired-find-file :before)
if (dired-get-file-for-visit ~= /^.*\.(pdf|wav|mp3|flac|...)/ ) {
  xah-open-in-external-app(dired-get-file-for-visit)
  return t
} 
#+END_SRC

*** Open in external programm

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2016-10-15"
  (interactive)
  (let* (
         (-file-list
          (if (string-equal major-mode "dired-mode")
              (dired-get-marked-files)
            (list (buffer-file-name))))
         (-do-it-p (if (<= (length -file-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))
    (when -do-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (-fpath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" -fpath t t))) -file-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (-fpath)
           (shell-command
            (concat "open " (shell-quote-argument -fpath))))  -file-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (-fpath) (let ((process-connection-type nil))
                            (start-process "" nil "xdg-open" -fpath))) -file-list))))))

(define-key dired-mode-map (kbd "C-<return>") 'xah-open-in-external-app)
#+END_SRC

*** Open in external file browser

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-desktop ()
  "Show current file in desktop (OS's file manager).
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2015-11-30"
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux")
    (let (
          (process-connection-type nil)
          (openFileProgram (if (file-exists-p "/usr/bin/gvfs-open")
                               "/usr/bin/gvfs-open"
                             "/usr/bin/xdg-open")))
      (start-process "" nil openFileProgram "."))
    ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. For example: with nautilus
    )))
#+END_SRC

*** Special keys
**** Copy path

Sometimes its useful to copy the path of a file or directory under cursor:

#+BEGIN_SRC emacs-lisp
(defun tl/dired-copy-path-at-point ()
	(interactive)
	(dired-copy-filename-as-kill 0)
)

(define-key dired-mode-map (kbd "W") 'tl/dired-copy-path-at-point)
#+END_SRC

**** Delete 

Delete with <delete> key.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<delete>") 'dired-do-delete)
#+END_SRC

*** dired-imenu

#+BEGIN_SRC emacs-lisp
(use-package dired-imenu
	:ensure t
	:init
	(require 'dired-imenu)
)
#+END_SRC

*** dired-k

#+BEGIN_SRC emacs-lisp
(use-package dired-k
	:ensure t
	:bind (:map dired-mode-map ("K" . dired-k))
	:config
  (progn
		;; FIXME: Tramp prompts for the password in every new dired buffer!
		;; (add-hook 'dired-initial-position-hook 'dired-k)
		;; (add-hook 'dired-after-readin-hook #'dired-k-no-revert)
))
#+END_SRC

*** dired-quick-sort

Depends on =ls=, the version of which should support =--group-directories-first=.
Activated in =dired= with <S-s>.

#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
	:ensure t
	:init
	(require 'dired-quick-sort)
	(dired-quick-sort-setup)
	)
#+END_SRC

*** dired+

#+BEGIN_SRC emacs-lisp
(use-package dired+
  :ensure t
  :config
  (require 'dired+)
  (setq diredp-hide-details-initially-flag nil)
  (set-face-foreground 'diredp-file-name nil)
  ;; Keep dired buffers updated when the file system changes.
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil))
#+END_SRC

<mouse-1> opens file/directory in the same window:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<mouse-2>") 'diredp-mouse-find-file)
#+END_SRC

*** dired-hacks

Several helper packages for dired.
See documentation here: https://github.com/Fuco1/dired-hacks

**** dired-narrow

Filter dired list on the fly:

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
							("/" . dired-narrow)
							:map dired-narrow-map
              ("<tab>" . dired-narrow-enter-directory)
              ("<right>" . dired-view-file)
							("<return>" . exit-minibuffer))        
	:config
	(setq dired-narrow-exit-action 'dired-narrow-find-file)
)
#+END_SRC

**** COMMENT dired-subtree

Taken from: https://github.com/Fuco1/.emacs.d/blob/master/files/dired-defs.el

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :init
  (bind-keys :map dired-mode-map
             :prefix "C-,"
             :prefix-map dired-subtree-map
             :prefix-docstring "Dired subtree map."
    ("<C-i-key>" . dired-subtree-insert)
    ("C-/" . dired-subtree-apply-filter)
    ("C-k" . dired-subtree-remove)
    ("C-n" . dired-subtree-next-sibling)
    ("C-p" . dired-subtree-previous-sibling)
    ("C-u" . dired-subtree-up)
    ("C-d" . dired-subtree-down)
    ("C-a" . dired-subtree-beginning)
    ("C-e" . dired-subtree-end)
    ("C-c" . dired-subtree-cycle)
    ("m" . dired-subtree-mark-subtree)
    ("u" . dired-subtree-unmark-subtree)
    ("C-o C-f" . dired-subtree-only-this-file)
    ("C-o C-d" . dired-subtree-only-this-directory)))

#+END_SRC

**** TODO dired-rainbow

More customizable highlightning in dired listings.
Settings inspired by https://github.com/Fuco1/.emacs.d/blob/master/files/dired-defs.el

- [ ] Does not seem to work.

#+BEGIN_SRC emacs-lisp
(defconst my-dired-media-files-extensions '("mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma")
  "Media file extensions that should launch in VLC.
Also used for highlighting.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-rainbow
	:ensure t 
  :config
  (progn
    (dired-rainbow-define html "#4e9a06" ("htm" "html" "xhtml"))
    (dired-rainbow-define xml "#b4fa70" ("xml" "xsd" "xsl" "xslt" "wsdl"))

    (dired-rainbow-define document "#fce94f" ("doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub"))
    (dired-rainbow-define excel "#3465a4" ("xlsx"))
    (dired-rainbow-define media "#ce5c00" my-dired-media-files-extensions)
    (dired-rainbow-define image "#ff4b4b" ("jpg" "png" "jpeg" "gif"))

    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define sourcefile "#fcaf3e" ("py" "c" "cc" "h" "java" "pl" "rb" "R" "php"))

    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#ad7fa8" ("zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#e6a8df" ("deb" "rpm"))
    (dired-rainbow-define encrypted "LightBlue" ("gpg" "pgp"))

    (dired-rainbow-define-chmod executable-unix "Green" "-.*x.*")
    ))
#+END_SRC

**** dired-ranger

#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
	:ensure t
  :config
  (setq dired-ranger-copy-ring-size 1)
	(define-key dired-mode-map (kbd "C-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)	; t adds item to dired-ranger-copy-ring
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-move)))
	(define-key dired-mode-map (kbd "M-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-paste)))
)
#+END_SRC

**** COMMENT dired-collapse

#+BEGIN_SRC emacs-lisp
(use-package dired-collapse
	:ensure t)
#+END_SRC

*** dired-efap

Rename file name at point.

#+BEGIN_SRC emacs-lisp
(use-package dired-efap
	:ensure t
	:config
	(setq dired-efap-initial-filename-selection nil)
	(define-key dired-mode-map (kbd "r") 'dired-efap)
	)
#+END_SRC

*** ediff 

Quick ediff on marked files.
Copied from https://oremacs.com/2017/03/18/dired-ediff/:
#+BEGIN_SRC emacs-lisp
(defun ora-ediff-files ()
  (interactive)
  (let ((files (dired-get-marked-files))
        (wnd (current-window-configuration)))
    (if (<= (length files) 2)
        (let ((file1 (car files))
              (file2 (if (cdr files)
                         (cadr files)
                       (read-file-name
                        "file: "
                        (dired-dwim-target-directory)))))
          (if (file-newer-than-file-p file1 file2)
              (ediff-files file2 file1)
            (ediff-files file1 file2))
          (add-hook 'ediff-after-quit-hook-internal
                    (lambda ()
                      (setq ediff-after-quit-hook-internal nil)
                      (set-window-configuration wnd))))
      (error "no more than 2 files should be marked"))))

(define-key dired-mode-map "e" 'ora-ediff-files)
#+END_SRC

*** imenu

Integrate imenu into dired.
Copied from https://fuco1.github.io/2017-05-01-Support-for-imenu-in-dired.html 

#+BEGIN_SRC emacs-lisp
(defun my-dired-imenu-prev-index-position (&optional arg)
  "Go to the header line of previous directory."
  (interactive "p")
  (unless (= (line-number-at-pos) 1)
    (call-interactively 'dired-prev-subdir)
    t))

(defun my-dired-extract-index-name ()
  "Extract name of the current item for imenu."
  (save-excursion
    (back-to-indentation)
    (buffer-substring-no-properties
     (point)
     (1- (re-search-forward ":$")))))

(defun my-dired-imenu-create-index ()
  "Create `imenu' index for dired."
  (let* ((alist (imenu-default-create-index-function))
         (uniquified (f-uniquify-alist (-map 'car alist))))
    (--remove
     (= 0 (length (car it)))
     (--map (cons (cdr (assoc (car it) uniquified)) (cdr it))
            alist))))

(defun my-dired-imenu-init ()
  "Initialize `imenu' variables in current buffer."
  (setq-local imenu-prev-index-position-function
              'my-dired-imenu-prev-index-position)
  (setq-local imenu-extract-index-name-function
              'my-dired-extract-index-name)
  (setq-local imenu-create-index-function
              'my-dired-imenu-create-index))

(add-hook 'dired-mode-hook 'my-dired-imenu-init)
#+END_SRC

*** TODO History

- [ ] I would like to be able to browse the dired history. =helm-dired-history= could be useful for this, but I don't know how to use it to this end.

**** COMMENT helm-dired-history

#+BEGIN_SRC emacs-lisp
(use-package helm-dired-history
	:ensure t
	:init	
	(require 'savehist)
	(add-to-list 'savehist-additional-variables 'helm-dired-history-variable)
	(savehist-mode 1)
	
	:config
	(with-eval-after-load 'dired
		(require 'helm-dired-history) 
		;; if you are using ido,you'd better disable ido for dired
		;; (define-key (cdr ido-minor-mode-map-entry) [remap dired] nil) ;in ido-setup-hook
		)
	)
#+END_SRC

*** size info 

Calculates the size of marked directories using =du=.
Copied from https://oremacs.com/2015/01/12/dired-file-size/ and slightly adapted.

#+BEGIN_SRC emacs-lisp
(defun dired-get-size ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "du" nil t nil "-sch" files)
      (message
       "Size of all marked files: %s"
       (progn
         (re-search-backward "\\(^[ 0-9.,]+[A-Za-z]+\\).*total$")
         (match-string 1))))))

(define-key dired-mode-map (kbd "z") 'dired-get-size)
#+END_SRC

** JavaScript

*** js2-mode

Major mode for JavaScript files.

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
	:ensure t
	:mode
	("\\.js\\'" . js2-mode)
	:config
	;; Better imenu
	(add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
	:ensure t
	:after js2-mode
	:config
	(add-hook 'js2-mode-hook #'js2-refactor-mode)
	(js2r-add-keybindings-with-prefix "C-c C-r")
	(define-key js2-mode-map (kbd "C-k") #'js2r-kill))
#+END_SRC

*** TODO indium

JavaScript development environment for Emacs

*** TODO tern

for better autocompletion

** org-mode

Must appear before LaTeX stuff!

Documentation and examples:
http://ehneilsen.net/notebook/orgExamples/org-examples.html
http://pages.sachachua.com/.emacs.d/Sacha.html#orgfe5d909
http://doc.norang.ca/org-mode.html#Setup
http://doc.rix.si/cce/cce-org.html

*** Export

Use a less intrusive export interface:

#+BEGIN_SRC emacs-lisp
(setq org-export-dispatch-use-expert-ui t)
#+END_SRC

Note that the last export command on the current buffer can be reused with =C-u C-c C-e=. 

*** Archive

Preserves the first heading of the org-mode file (found in http://orgmode.org/worg/org-hacks.html#orgheadline59):

#+BEGIN_SRC emacs-lisp
(defadvice org-archive-subtree (around my-org-archive-subtree activate)
  (let ((org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it))
#+END_SRC

*** babel

Preserve indentation in source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

Don't ask for confirmation when evaluating source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Fontify source blocks as defined for the  enclosed language: 
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Use tab key as defined for the enclosed language:
#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

*** Download

****  org-download

#+BEGIN_SRC emacs-lisp
(use-package org-download
	:ensure t
	:after org
	:config
	(setq org-download-method 'attach))
#+END_SRC

*** General keys

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9> c") 'org-goto-calendar)
  (global-set-key (kbd "<f9> a") 'org-agenda-list)
  (global-set-key (kbd "<f9> t") 'org-todo-list)
  (global-set-key (kbd "C-<f9>") 'org-cycle-agenda-files)
  (global-set-key (kbd "<f9> s") 'org-search-view)
  (global-set-key (kbd "<f9> f") 'org-search-view)
  (global-set-key (kbd "<f9> l") 'org-tags-view)
  (global-set-key (kbd "<f9> r") 'org-reload)
  (global-set-key (kbd "<f9> w")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/work/work.org"))))
  (global-set-key (kbd "<f9> n")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/notes.org"))))
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-<tab>") nil )
    (define-key org-mode-map (kbd "S-<up>") nil )
    (define-key org-mode-map (kbd "S-<down>") nil )
    (define-key org-mode-map (kbd "S-<left>") nil )
    (define-key org-mode-map (kbd "S-<right>") nil )
    (define-key org-mode-map (kbd "C-n") 'org-next-visible-heading )
		(define-key org-mode-map (kbd "C-p") 'org-previous-visible-heading )
    (define-key org-mode-map (kbd "C-S-p") 'org-backward-heading-same-level)
		(define-key org-mode-map (kbd "C-S-n") '(lambda () (interactive) (org-backward-heading-same-level -1)))
    (define-key org-mode-map (kbd "C-c C-f") 'org-footnote-action )
		(define-key org-mode-map (kbd "C-c C-t") 'org-todo )
    (define-key org-mode-map (kbd "C-c C-x C-b") 'org-tree-to-indirect-buffer ))

  ;; (with-eval-after-load 'org-agenda
  ;;   (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+END_SRC

*** General appearence

**** Lists

Set indentation of list items:

#+BEGIN_SRC emacs-lisp
(setq-default org-list-indent-offset 4)
#+END_SRC

Show bullet instead of - or *.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^[[:space:]]*\\(-\\) "
		(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

;; ;; The following tries to estimate the embedding level via the number of preceding spaces.
;;
;; (font-lock-add-keywords
;;  'org-mode
;;  '(("^\\(-\\) "
;; 		(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
;;
;; (font-lock-add-keywords
;;  'org-mode
;;  `((,(concat "^[[:space:]]\\{" (number-to-string (+ 2 org-list-indent-offset)) "\\}\\(-\\) ")
;; 		(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))
;;
;; (font-lock-add-keywords
;;  'org-mode
;;  `((,(concat "^[[:space:]]\\{" (number-to-string 
;; 																(* 2 (+ 2 org-list-indent-offset))) "\\}\\(-\\) ")
;; 		(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "▸"))))))
;;
;; (font-lock-add-keywords
;;  'org-mode
;;  `((,(concat "^[[:space:]]\\{" (number-to-string 
;; 																(* 3 (+ 2 org-list-indent-offset))) "\\}\\(-\\) ")
;; 		(0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "▹"))))))

;; ;; Trying to make bullet face aware of embedding depth:
;;
;; (font-lock-add-keywords
;;  'org-mode
;;  '(("^[[:space:]]*\\(-\\) "
;;     (0 (prog1 () (let ((bullet "-")
;; 											 (depth (org-list--depth (org-element-at-point))))
;; 									 (cond ((= depth 2) (setq bullet "•"))
;; 												 ((= depth 3) (setq bullet "▸"))
;; 												 ((= depth 4) (setq bullet "-"))
;; 												 ((= depth 5) (setq bullet "▪"))
;; 												 )
;; 									 (compose-region (match-beginning 1) (match-end 1) bullet)))))))
#+end_src

Allow for alphabetical list item labels:

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

**** Color text

Text can be colored using the link syntax, e.g. [[color:red][this is red]].
Taken from https://github.com/jkitchin/jmax/blob/master/org-colored-text.el
See also http://kitchingroup.cheme.cmu.edu/blog/2016/01/16/Colored-text-in-org-mode-with-export-to-HTML/

#+BEGIN_SRC emacs-lisp
(require 'org-colored-text)
#+END_SRC

Add support for export to LaTeX:

#+BEGIN_SRC emacs-lisp
;; Taken and adapted from org-colored-text
(org-add-link-type
 "color"
 (lambda (path)
   "No follow action.")
 (lambda (color description backend)
   (cond
		((eq backend 'latex)									; added by TL
     (format "{\\color{%s}%s}" color description)) ; added by TL
    ((eq backend 'html)
     (let ((rgb (assoc color color-name-rgb-alist))
					 r g b)
       (if rgb
					 (progn
						 (setq r (* 255 (/ (nth 1 rgb) 65535.0))
									 g (* 255 (/ (nth 2 rgb) 65535.0))
									 b (* 255 (/ (nth 3 rgb) 65535.0)))
						 (format "<span style=\"color: rgb(%s,%s,%s)\">%s</span>"
										 (truncate r) (truncate g) (truncate b)
										 (or description color)))
				 (format "No Color RGB for %s" color)))))))
#+END_SRC

***** Other link types

Link type for typesetting linguistic examples:
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "bsp"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)								
						 (format "\\bsp{%s}" (or desc path)))
						((eq 'html backend)
             (format "<font color=\"blue\">%s</font>"
                     (or desc path)))))
 :face '(:foreground "CornflowerBlue"	:slant italic	:weight bold		)
 :help-echo "This will be exported as example.")

(org-link-set-parameters
 "bspcolor"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)								
						 (format "\\bspcolor{%s}" (or desc path)))
						((eq 'html backend)
             (format "<font color=\"blue\">%s</font>"
                     (or desc path)))))
 :face '(:foreground "CornflowerBlue")
 :help-echo "This will be exported in the color of examples.")
#+END_SRC

Link type for typesetting terminology:
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "term"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)								
						 (format "\\term{%s}" (or desc path)))
						((eq 'html backend)
             (format "<span style=\"font-variant:small-caps;\">%s</span>" 
										 (or desc path)))))
 :face '(:box t :slant normal)
 :help-echo "This will be exported as term."
 )
#+END_SRC

Link type for typesetting emphasized text:
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "emph"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)								
						 (format "\\emph{%s}" (or desc path)))
						((eq 'html backend)
             (format "<em>%s</em>"
                     (or desc path)))))
 :face '(:overline t :underline t :slant italic)
 :help-echo "This will be exported as emphasized text."
 )
#+END_SRC

Link type for typesetting small caps:
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "textsc"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)
						 (if path
								 (format "{\\color{%s}\\textsc{%s}}" path desc)
							 (format "\\textsc{%s}" desc)))
						((eq 'html backend)
						 (format "<span style=\"font-variant:small-caps;\">%s</span>" 
										 (or desc path)))))
 :face (lambda (path)
				 `(:box t :slant normal  
								:foreground ,(if (not (string= "" path)) "CornflowerBlue")))
 :help-echo "This will be exported in small caps.")
#+END_SRC

Link type for typesetting with typewriter font:
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "texttt"
 :follow (lambda (path) (message "You clicked me."))
 :export (lambda (path desc backend)
           (cond
            ((eq backend 'latex)
						 (if path
								 (format "{\\color{%s}\\texttt{%s}}" path desc)
							 (format "\\texttt{%s}" desc)))
						((eq 'html backend)
						 (format "<span style=\"font-family:monospace;\">%s</span>" 
										 (or desc path)))))
 :face (lambda (path)
				 `(:box t :slant normal :family ,custom-fixed-pitch-font  
								:foreground ,(if (not (string= "" path)) "CornflowerBlue")))
 :help-echo "This will be exported in small caps.")
#+END_SRC

**** Fonts

General settings:

#+begin_src emacs-lisp
	(add-hook 'org-mode-hook (lambda ()
														 (variable-pitch-mode t)
														 ;; (text-scale-increase 0.5)
														 ))

	(with-eval-after-load 'org
		(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-latex-and-related nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-link nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-tag nil :inherit 'fixed-pitch)
		)

	(setq org-hide-emphasis-markers t)
#+end_src

Modify some faces:

#+BEGIN_SRC emacs-lisp
(face-spec-set 'org-todo '((t (:overline t))))
(face-spec-set 'org-done '((t (:overline t))))
#+END_SRC

Overwrite some faces:

#+begin_src emacs-lisp
(custom-set-faces
 '(org-block ((t (:inherit fixed-pitch )))) ; org-mode >9
 '(org-block-background ((t (:inherit fixed-pitch))))
 '(org-block-begin-line ((t (:underline t))))
 '(org-block-end-line  ((t (:overline t))))
 '(org-level-1 ((t (:inherit outline-1 :overline t :weight semi-bold ))))
 '(org-level-2 ((t (:inherit outline-2 :overline t :weight semi-bold ))))
 '(org-level-3 ((t (:inherit outline-3 :weight semi-bold ))))
 '(org-level-4 ((t (:inherit outline-4 :weight semi-bold ))))
 '(org-level-5 ((t (:inherit outline-5 :weight semi-bold ))))
 )
#+end_src

Further attributes: =:background=, =:height=

**** Bullets, folding symbols, HTML and LaTeX symbols

Nicer bullets:

#+begin_src emacs-lisp
;; (use-package org-bullets
;; 	:ensure t
;; 	:init
;; 	(setq org-bullets-bullet-list
;; 				'("◉" "◎" "○" "●" "►" "♦" "◇"))
;; 	:config 
;; 	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
;; 	)
#+end_src

Folding symbol:

#+begin_src emacs-lisp
(setq org-ellipsis " ▼")
#+end_src

Replace HTML/LaTeX code by UTF-8 characters (see org-pretty-entities for an enumeration):

#+begin_src emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

**** Editing

Do not edit in invisible areas of the buffer:

#+BEGIN_SRC emacs-lisp
(setq-default org-catch-invisible-edits 'show)
#+END_SRC

**** TODO Inline code 
:LOGBOOK:
- State "TODO"       from              [2018-10-24 Wed 23:02]
:END:

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 
 'org-mode
 '(("\\(@@latex:\\)\\(.*?\\)\\(@@\\)"
		(1 font-lock-comment-face)
		(2 '(org-latex-and-related))
		(3 font-lock-comment-face))
	 ))

(font-lock-add-keywords 
 'org-mode
 '(("\\(@@beamer:\\)\\(.*?\\)\\(@@\\)"
		(1 font-lock-comment-face)
		(2 '(org-latex-and-related))
		(3 font-lock-comment-face))
	 ))

(font-lock-add-keywords 
 'org-mode
 '(("\\(@@html:\\)\\(.*?\\)\\(@@\\)"
		(1 font-lock-comment-face)
		(2 '(org-latex-and-related)) 				; FIXME?
		(3 font-lock-comment-face))
	 ))

;; Does not work
(font-lock-add-keywords 
 'org-mode
 '(("\\(#\\+BEAMER_HEADER:\\)\\(.*\\)"
		(1 font-lock-comment-face)
		(2 '(org-latex-and-related)))
	 ))
#+END_SRC

**** Checkboxes

Fontify checkbox items. 
(inspired by https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html)

#+BEGIN_SRC emacs-lisp
(defface org-checkbox-todo-text
	'((t (;;:inherit org-todo
								 :overline nil
								 :foreground "red"
								 :weight unspecified)))
	"Face for the text part of an unchecked org-mode checkbox.")

(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?: \\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-todo-text prepend))
 'append)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defface org-checkbox-done-text
	'((t (;;:inherit org-done
								 :overline nil
								 :foreground "forest green"
								 :weight unspecified)))
	"Face for the text part of a checked org-mode checkbox.")

(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-checkbox-done-text prepend))
 'append)
#+END_SRC

**** Math formulas

Toggle LaTeX images of math formulas when cursor is at point.

Taken from http://kitchingroup.cheme.cmu.edu/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment/

#+BEGIN_SRC emacs-lisp
(defvar org-latex-fragment-last nil
  "Holds last fragment/environment you were on.")

(defun org-latex-fragment-toggle ()
  "Toggle a latex fragment image "
  (and (eq 'org-mode major-mode)
       (let* ((el (org-element-context))
              (el-type (car el)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            org-latex-fragment-last
            ;; and are on a fragment now
            (or
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type))
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (= (org-element-property :begin el)
                    (org-element-property :begin org-latex-fragment-last))))
           ;; go back to last one and put image back
           (save-excursion
             (goto-char (org-element-property :begin org-latex-fragment-last))
             (org-preview-latex-fragment))
           ;; now remove current image
           (goto-char (org-element-property :begin el))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov)))
           ;; and save new fragment
           (setq org-latex-fragment-last el))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not (or
                  (eq 'latex-fragment el-type)
                  (eq 'latex-environment el-type)))
            ;; but we were on one
            org-latex-fragment-last)
           ;; put image back on
           (save-excursion
             (goto-char (org-element-property :begin org-latex-fragment-last))
             (org-preview-latex-fragment))
           ;; unset last fragment
           (setq org-latex-fragment-last nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not org-latex-fragment-last)
            ;; but now we are
            (or
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type)))
           (goto-char (org-element-property :begin el))
           ;; remove image
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov)))
           (setq org-latex-fragment-last el))))))

;; (add-hook 'post-command-hook 'org-latex-fragment-toggle)
#+END_SRC

Toggle =org-latex-fragment-toggle=:
#+BEGIN_SRC emacs-lisp
(defun org-latex-fragment-toggle-toggle ()
	(interactive)
	(if (memq 'org-latex-fragment-toggle (default-value 'post-command-hook))
			(progn 
				(remove-hook 'post-command-hook 'org-latex-fragment-toggle)
				(org-remove-latex-fragment-image-overlays))
		(add-hook 'post-command-hook 'org-latex-fragment-toggle)
		(org-toggle-latex-fragment '(16))) 	; equivalent to: C-u C-u org-toggle-latex-fragment
	)
#+END_SRC

**** Sticky headers

Show current header in first line of buffer.

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
	:ensure t
	:config
	(setq org-sticky-header-always-show-header t
				org-sticky-header-prefix nil 		; don't indent sticky header
				org-sticky-header-full-path 'full) ; values: nil, 'full, 'reversed
	(add-hook 'org-mode-hook 'org-sticky-header-mode))
#+END_SRC

**** Outline

Only unfold current heading and its content:

#+BEGIN_SRC emacs-lisp
;; Taken from https://stackoverflow.com/a/28031539/6452961
;; and slightly modified.
(defun org-show-current-heading-tidily ()
  "Show entry under point, keeping other entries closed."
  (interactive) 
	(save-excursion
		(if (save-excursion (end-of-line) (outline-invisible-p))
				(progn (org-show-entry) (show-children))
			(outline-back-to-heading)
			(unless (and (bolp) (org-on-heading-p))
				(org-up-heading-safe)
				(hide-subtree)
				(error "Boundary reached"))
			(org-overview)
			(org-reveal t)
			(org-show-entry)
			(show-children))))
#+END_SRC

*** Modules

See http://orgmode.org/worg/org-contrib/

#+BEGIN_SRC emacs-lisp
;; (setq org-modules '( ;; org-bbdb
;;                       ;; org-gnus
;;                       ;; org-drill
;;                       ;; org-info
;;                       ;; org-jsinfo
;;                       ;; org-habit
;;                       ;; org-irc
;;                       ;; org-mouse
;;                       ;; org-protocol
;;                       ;; org-annotate-file
;;                       ;; org-eval
;;                       ;; org-expiry
;;                       ;; org-interactive-query
;;                       ;; org-man
;;                       ;; org-collector
;;                       ;; org-panel
;;                       ;; org-screen
;;                       ;; org-toc
;; 											))
;; (eval-after-load 'org
;;  '(org-load-modules-maybe t))
;; (setq org-expiry-inactive-timestamps t)
#+END_SRC

*** Miscellaneous settings

Selection
#+BEGIN_SRC emacs-lisp
(setq org-support-shift-select t)
#+END_SRC

Block
#+BEGIN_SRC emacs-lisp
(setq org-hide-block-startup t) 				; hide blocks at startup
#+END_SRC

Indent automatically
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

Support for inline tasks
#+BEGIN_SRC emacs-lisp
(load "org-inlinetask")
(define-key org-mode-map (kbd "C-c C-x C-t") 'org-inlinetask-insert-task)
#+END_SRC

C-a and C-e behave org-sensitive
#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
#+END_SRC

Footnotes
#+BEGIN_SRC emacs-lisp
(setq org-footnote-define-inline t
			org-footnote-auto-adjust t)
#+END_SRC

Jump
#+BEGIN_SRC emacs-lisp
(setq org-goto-interface 'outline-path-completion
      org-goto-max-level 10)
#+END_SRC

*** Todo keywords

(Must appear before =org-agenda= settings. Otherwise =org-todo-keywords= may not get updated buffer locally.)

From the org-mode documentation (http://orgmode.org/worg/doc.html#org-todo-keywords):
#+BEGIN_QUOTE
"WAIT(w@/!)".  "@" means to add a note (with time), "!" means to record only the time of the state change.  With X and Y being either "@" or "!", "X/Y" means use X when entering the state, and use Y when leaving the state if and only if the *target* state does not define X.  You may omit any of the fast-selection key or X or /Y, so WAIT(w@), WAIT(w/@) and WAIT(@/@) are all valid.
#+END_QUOTE

- TODO: something that needs to be done, maybe now, maybe later. 
- NEXT: something that can be done /now/. There's everything you need to start doing it.
- INPROGRESS: something that is being done right now.
- APPT: appointment (meeting, phone call etc.) with a fixed date.
- WAITING: something that cannot be done now, because some prerequisites are not yet met.
- HOLD: something that cannot be done now, and the prerequisites are unlikely to be fullfilled in the future.
- SOMEDAY: you are not yet sure whether this needs to be done.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t!)" "NEXT(n)" "INPROGRESS(p!)" "APPT(a)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "SOMEDAY(s)" "|" "CANCELLED(c@/!)"))))

(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("INPROGRESS" :foreground "gold" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)
              ("APPT" :foreground "forest green" :weight bold)
							("SOMEDAY" :foreground "forest green" :weight bold)
							)))
#+END_SRC

Fast TODO selection:
#+BEGIN_SRC emacs-lisp
(setq org-use-fast-todo-selection t)
#+END_SRC

Insert timestamp when task is marked as DONE:
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

Insert timestamp when changing deadline:
#+BEGIN_SRC emacs-lisp
(setq org-log-redeadline 'time)
#+END_SRC

Insert timestamp when changing schedule:
#+BEGIN_SRC emacs-lisp
(setq org-log-reschedule 'time)
#+END_SRC

Observe dependencies between TODOs:
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

*** Clocking and logging

Collect log entries in drawer:
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC

Clock out when quitting emacs:
#+BEGIN_SRC emacs-lisp
;; Taken from https://emacs.stackexchange.com/a/38487/12336
(defun my/org-clock-query-out ()
  "Ask the user before clocking out.
This is a useful function for adding to `kill-emacs-query-functions'."
  (if (and
       (featurep 'org-clock)
       (funcall 'org-clocking-p)
       (y-or-n-p "You are currently clocking time, clock out? "))
      (org-clock-out) 
    t)) ;; only fails on keyboard quit or error

;; timeclock.el puts this on the wrong hook!
(add-hook 'kill-emacs-query-functions 'my/org-clock-query-out)
#+END_SRC

Only use hours and minutes as duration format in clocktables:
#+BEGIN_SRC emacs-lisp
(setq org-duration-format (quote h:mm))
#+END_SRC

*** Newline/<return>

Split the line with =M-<return>=. Disables =org-table-wrap-region= when set to =nil=.
#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default . t)))
#+END_SRC

The following is taken from [[http://github.com/jkitchin/scimax/blob/master/scimax-org.el]] . 
See also http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/ .

#+BEGIN_SRC emacs-lisp
(require 'org-inlinetask)

(defun scimax/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond

     ((eq 'line-break (car (org-element-context)))
      (org-return-indent))

     ;; Open links like usual, unless point is at the end of a line.
     ;; and if at beginning of line, just press enter.
     ((or (and (eq 'link (car (org-element-context))) (not (eolp)))
					(bolp))
      (org-return))

     ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
     ;; Johansson!
     ((org-inlinetask-in-task-p)
      (org-return))

     ;; checkboxes - add new or delete empty
     ((org-at-item-checkbox-p)
      (cond
       ;; at the end of a line.
       ((and (eolp)
						 (not (eq 'item (car (org-element-context)))))
				(org-insert-todo-heading nil))
       ;; no content, delete
       ((and (eolp) (eq 'item (car (org-element-context))))
				(setf (buffer-substring (line-beginning-position) (point)) ""))
       ((eq 'paragraph (car (org-element-context)))
				(goto-char (org-element-property :end (org-element-context)))
				(org-insert-todo-heading nil))
       (t
				(org-return))))

     ;; lists end with two blank lines, so we need to make sure we are also not
     ;; at the beginning of a line to avoid a loop where a new entry gets
     ;; created with only one blank line.
     ((org-in-item-p)
      (cond
       ;; empty definition list
       ((and (looking-at " ::")
						 (looking-back "- " 3))
				(beginning-of-line)
				(delete-region (line-beginning-position) (line-end-position)))
       ;; empty item
       ((and (looking-at "$")
						 (looking-back "- " 3))
				(beginning-of-line)
				(delete-region (line-beginning-position) (line-end-position)))
       ;; ;; numbered list (original)
       ;; ((and (looking-at "$")
			 ;; 			 (looking-back "[0-9]+. " (line-beginning-position)))
			 ;; 	(beginning-of-line)
			 ;; 	(delete-region (line-beginning-position) (line-end-position)))
			 ;; numbered or alphabetical list (changed by TL)
       ((save-excursion
					(beginning-of-line)
					(or (looking-at " *[0-9]+. *$")
							(looking-at " *[a-zA-Z]. *$")))
				(beginning-of-line)
				(delete-region (line-beginning-position) (line-end-position)))
       ;; insert new item
       (t
				(end-of-line)
				(org-insert-item))))

     ;; org-heading
     ((org-at-heading-p)
      (if (not (string= "" (org-element-property :title (org-element-context))))
					(progn
						;; Go to end of subtree suggested by Pablo GG on Disqus post.
						(org-end-of-subtree)
						(org-insert-heading-respect-content)
						(outline-show-entry))
				;; The heading was empty, so we delete it
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")))

     ;; tables
     ((org-at-table-p)
      (if (-any?
					 (lambda (x) (not (string= "" x)))
					 (nth
						(- (org-table-current-dline) 1)
						(remove 'hline (org-table-to-lisp))))
					(org-return)
				;; empty row
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")
				(org-return)))

     ;; fall-through case
     (t
      (org-return)))))
#+END_SRC

Shift-return:

#+BEGIN_SRC emacs-lisp
(defun tl/org-shift-return ()
	(interactive)
  (cond
	 ;; in org-table
	 ((org-table-p)
		(org-return))
	 ;; else
	 (t (smart-open-line))
	 )
  )
#+END_SRC

Set keys:

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
	(define-key org-mode-map (kbd "<return>") 'scimax/org-return) ; not org-table-next-row
	(define-key org-mode-map (kbd "S-<return>") 'tl/org-shift-return )) ; not org-table-copy-down
#+END_SRC

**** COMMENT Old stuff

This is an old version of scimax/org-return that I modified.

#+BEGIN_SRC emacs-lisp
(require 'org-inlinetask)

(defun scimax/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond

     ((eq 'line-break (car (org-element-context)))
      (org-return-indent))

     ;; Open links like usual, unless point is at the end of a line.
     ;; and if at beginning of line, just press enter.
     ((or (and (eq 'link (car (org-element-context))) (not (eolp)))
					(bolp))
      (org-return))

     ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
     ;; Johansson!
     ((org-inlinetask-in-task-p)
      (org-return))

     ;; checkboxes too
     ;; ((org-at-item-checkbox-p)  ; commented by TL: Does not recognize empty items.
     ;;  (org-insert-todo-heading nil))  ; commented by TL: Does not recognize empty items.

     ;; lists end with two blank lines, so we need to make sure we are also not
     ;; at the beginning of a line to avoid a loop where a new entry gets
     ;; created with only one blank line.
     ((org-in-item-p)
      ;; (if (save-excursion (beginning-of-line) (org-element-property :contents-begin (org-element-context)))
			(if (org-element-property :contents-end (org-element-context)) ; added by TL
					(if (not (re-search-forward "[[:graph:]]" (line-end-position) t)) ; added by TL: use org-return when character follows in line
							(if (org-at-item-checkbox-p)			;added by TL
									(org-insert-todo-heading nil) ; added by TL
								;; (org-insert-heading) ; commented by TL
								(org-insert-item)				; added by TL
								)												; added by TL
						(backward-char)							; added by TL: re-search-forward moves point
						(org-return))								; added by TL
				(beginning-of-line)
				(delete-region (line-beginning-position) (line-end-position))
				(org-return)))

     ;; org-heading
     ((org-at-heading-p)
      (if (not (string= "" (org-element-property :title (org-element-context))))
					(if (not (re-search-forward "[[:graph:]]" (line-end-position) t)) ; added by TL: use org-return when character follows in line
							(progn (org-end-of-meta-data)
										 ;; (org-insert-heading-respect-content) ; commented by TL: heading is sometimes added after *next* heading.
										 (org-insert-heading) ; added by TL
										 (outline-show-entry))
						(backward-char)							; added by TL: re-search-forward moves point
						(org-return))								; added by TL
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")))

     ;; tables
     ((org-at-table-p)
      (if (-any?
					 (lambda (x) (not (string= "" x)))
					 (nth
						(- (org-table-current-dline) 1)
						(remove 'hline (org-table-to-lisp))))
					(org-return)
				;; empty row
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")
				(org-return)))

     ;; fall-through case
     (t
      (org-return)))))
#+END_SRC

Here's my own version, which uses =org-table-wrap-region=. This was superseded by =scimax/org-return=.

#+BEGIN_SRC emacs-lisp
(defun tl/org-return ()
	(interactive)
	(cond
	 ;; in org-table
	 ((org-table-p)
		(let ((home (point)))
			(when (not (looking-at ".*\|")) ; right of the rightmost vertical bar?
				(if (and (looking-at "[[:space:]]*$")	; empty cell?
								 (looking-back "\|[[:space:]]*"))
						(progn											; true: use org-return
							(org-return)
							(t))
					(end-of-line)									; false: insert new table row
					(insert "\|")
					(org-table-insert-row t)
					(goto-char home)))
			(org-table-wrap-region nil)				; only works in cells embraced by vertical bars
			))
	 ;; else
	 (t (org-return))
	 )
  )
#+END_SRC

*** LaTeX support

Load export module for LaTeX:
#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
#+END_SRC

Headlines with =:ignore:= tag are ignored during export, but not their body:
#+BEGIN_SRC emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

Support from org-babel:
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((latex . t)))
(setq org-highlight-latex-and-related '(latex script entities)) ; inline sytax highlighting
;; (add-to-list 'org-latex-packages-alist '("" "tikz" t))					; unfortunately this breaks the color of fonts in inline previews
;; (add-to-list 'org-latex-packages-alist '("" "forest" t))
#+END_SRC

Scale LaTeX previews:
#+BEGIN_SRC emacs-lisp
;; static
;; (plist-put org-format-latex-options :scale 2) ; scale inline PNGs

;; dynamic (http://emacs.stackexchange.com/a/13032/12336)
(defun update-org-latex-fragment-scale ()
  (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
    (plist-put org-format-latex-options :scale (* 2.3 text-scale-factor)))
)
(add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale)
#+END_SRC

Use LaTeXmk:
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process (list "latexmk -f -pdf %f -cd %o"))
;; The option "-cd %o" is needed when executing babel source blocks, 
;; during which the auxiliary files are moved to some temporary directory.
;; Instead of "-cd %o", one could also use "-outdir=%o". 
;; See the discussion here:
;; https://github.com/fniessen/refcard-org-beamer/commit/9f75e013127940e793e0a925fc4ee222bae0e45c
#+END_SRC

Add some classes to the set of known classes:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
         '("tl-abstract" 
						"\\documentclass{article}
						[NO-DEFAULT-PACKAGES]"
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
         '("tl-article" 
						"\\documentclass{scrartcl}
						[NO-DEFAULT-PACKAGES]"
						("\\section{%s}" . "\\section*{%s}") 
						("\\subsection{%s}" . "\\subsection*{%s}") 
						("\\subsubsection{%s}" . "\\subsubsection*{%s}")
						("\\paragraph{%s}" . "\\paragraph*{%s}")))
#+END_SRC

Add the class [[https://github.com/langsci/latex][langscibook]] to the set of known classes:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
						 '("langscibook" 
							 "\\documentclass{langsci/langscibook}
				    		[NO-DEFAULT-PACKAGES]" 
							 ("\\part{%s}" . "\\part*{%s}") 
							 ("\\chapter{%s}" . "\\chapter*{%s}") 
							 ("\\section{%s}" . "\\section*{%s}") 
							 ("\\subsection{%s}" . "\\subsection*{%s}") 
							 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
							 ("\\paragraph{%s}" . "\\paragraph*{%s}")
							 ))

(add-to-list 'org-latex-classes
						 '("langscibook-paper" 
							 "\\documentclass[output=paper]{langsci/langscibook}
				    		[NO-DEFAULT-PACKAGES]" 
							 ("\\section{%s}" . "\\section*{%s}") 
							 ("\\subsection{%s}" . "\\subsection*{%s}") 
							 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
							 ("\\paragraph{%s}" . "\\paragraph*{%s}")
							 ))
#+END_SRC

Use =#+NAME:= field as argument of =\label= during export:
#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC

*** COMMENT org-gcal

Integrate Google Calendar with =org-gcal=.
I don't use =org-gcal= any more.

#+BEGIN_SRC emacs-lisp
(setq package-check-signature nil)

(use-package org-gcal
	:ensure t
	:config
	(when (file-exists-p (expand-file-name "gcal-credentials.el" private-emacs-settings-dir))
		(load-file (expand-file-name "gcal-credentials.el" private-emacs-settings-dir))
		(setq org-gcal-client-id my-org-gcal-client-id
					org-gcal-client-secret my-org-gcal-client-secret
					org-gcal-file-alist '((my-gmail-address .  (concat org-notes-dir "gcal.org"))))
		))
#+END_SRC

*** org-ref

- [X] =org-ref-prefer-bracket-links= does not work?
- [X] =org-ref-cite-color= is not used 

#+BEGIN_SRC emacs-lisp
;; (setq org-ref-completion-library 'org-ref-ivy-cite) ; must appear before org-ref
(use-package org-ref
	:ensure t
	:after org
	:init
	(require 'org-ref) 										; don't know why I need this
	(setq org-ref-default-bibliography (list user-bibliography-file)
				;; org-ref-bibliography-notes "~/bibliography/notes.org"
				org-ref-pdf-directory user-bibliography-pdf-dir
				org-ref-prefer-bracket-links t
				org-ref-default-ref-type "autoref"
				)
	:config
	:bind (:map org-mode-map
							("C-c ]" . org-ref-helm-insert-cite-link)
							("C-c )" . org-ref-helm-insert-ref-link)
							("C-c (" . org-ref-helm-insert-label-link))
)
#+END_SRC

Add \citeauthoryear and  \citealtauthoryear to org-ref:
#+BEGIN_SRC emacs-lisp
(org-ref-define-citation-link "citeauthoryear")
(add-to-list 'org-ref-cite-types "citeauthoryear")
(org-ref-define-citation-link "citealtauthoryear")
(add-to-list 'org-ref-cite-types "citealtauthoryear")
#+END_SRC

Set colors:
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(org-ref-label-color "magenta")
 '(org-ref-ref-color "LimeGreen")
 '(org-ref-cite-color "ForestGreen")
 )
#+END_SRC

TODO: Change format entry string with =org-ref-formatted-citation-formats=:

*** org-reveal

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
	:ensure ox-reveal)

;; (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-root "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.4.1/")
(setq org-reveal-mathjax t)

(use-package htmlize
	:ensure t)
#+END_SRC

*** org-show

Simple interactive presentations from within Emacs.
See https://github.com/jkitchin/jmax/blob/master/org/org-show.org for more information.

#+BEGIN_SRC emacs-lisp
(require 'org-show) 
#+END_SRC

*** TODO org-beamer

- [ ] add export of text colored with `color:` links (see [[color:red][Color text]])

Documentation:
- https://github.com/fniessen/refcard-org-beamer
- http://orgmode.org/tmp/worg/org-tutorials/org-latex-export.html

Load support for exporting LaTeX beamer presentations:
#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)
#+END_SRC

Add virtual beamer class (=tl-beamer=) to the known LaTeX classes:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
         '("tl-beamer" 
						"\\documentclass{beamer}
						[NO-DEFAULT-PACKAGES]"
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

Change export of bold font:
#+BEGIN_SRC emacs-lisp
(defun my-beamer-bold (contents backend info)
  (when (eq backend 'beamer)
    (replace-regexp-in-string "\\`\\\\[A-Za-z0-9]+" "\\\\textbf" contents)))

(add-to-list 'org-export-filter-bold-functions 'my-beamer-bold)
#+END_SRC

Change export of italic font:
#+BEGIN_SRC emacs-lisp
(defun my-beamer-italic (contents backend info)
  (when (eq backend 'beamer)
    (replace-regexp-in-string "\\`\\\\[A-Za-z0-9]+" "\\\\textit" contents)))

(add-to-list 'org-export-filter-italic-functions 'my-beamer-italic)
#+END_SRC

*** Graphviz/dot support

 #+BEGIN_SRC emacs-lisp
(add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
(org-babel-do-load-languages  'org-babel-load-languages '((dot . t)))
#+END_SRC

*** TODO Gnuplot support

- [ ] compiling Gnuplot source blocks crashes Emacs

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((gnuplot . t)))
#+END_SRC

*** TODO COMMENT R support

- [ ] as of Org 9.1, this throws =(invalid-function org-babel-header-args-safe-fn)= due to =org-babel-R-command=

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((R . t)))
(setq org-babel-R-command "R --slave --no-save")
#+END_SRC

*** Refile

Following this excellent blog post: https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files :maxlevel . 3))
			org-refile-use-outline-path 'file
			org-outline-path-complete-in-steps nil
			org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

*** Plantuml

http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html

 #+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages  'org-babel-load-languages '((plantuml . t)))
#+END_SRC

*** Spell checking

#+BEGIN_SRC emacs-lisp
;; ispell
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\|SETTINGS\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXPORT" . "#\\+END_EXPORT"))
;; flyspell
;; http://emacs.stackexchange.com/a/9347/12336
;; NO spell check for embedded snippets
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let ((rlt ad-return-value)
        (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|export\\)")
        (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|export\\)")
        old-flag
        b e)
    (when ad-return-value
      (save-excursion
        (setq old-flag case-fold-search)
        (setq case-fold-search t)
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t)))
        (setq case-fold-search old-flag))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

*** Agenda

**** Appearance

Don't split window when opening agenda:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup "current-window")
#+END_SRC

Show notifications of agenda events:
#+BEGIN_SRC emacs-lisp
(use-package org-alert
	:ensure t
	)
#+END_SRC

Customize agenda view:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
			'(("w" "Work-related agenda and tasks"
				 ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
								 (org-agenda-overriding-header "High-priority tasks:")))
					(agenda "")
					(todo "INPROGRESS"
								((org-agenda-overriding-header "Normal-priority tasks:")))
					(todo "NEXT" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "WAITING" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					(todo "TODO" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "SOMEDAY" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					;; (tags-todo "@work"
					;; 					 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("NEXT")))
					;; 						(org-agenda-overriding-header "")
					;; 						(org-agenda-block-separator nil)))
					)
				 ((org-agenda-tag-filter-preset '("+@work"))))

				("h" "Home-related agenda and tasks"
				 ((tags "PRIORITY=\"A\""
								((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
								 (org-agenda-overriding-header "High-priority tasks:")))
					(agenda "")
					(todo "INPROGRESS"
								((org-agenda-overriding-header "Normal-priority tasks:")))
					(todo "NEXT" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "WAITING" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					(todo "TODO" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "SOMEDAY" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					)
				 ((org-agenda-tag-filter-preset '("+@home"))))

				("c" "Complete list of agenda and tasks"
				 ((tags "PRIORITY=\"A\""
								((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
								 (org-agenda-overriding-header "High-priority tasks:")))
					(agenda "")
					(todo "INPROGRESS"
								((org-agenda-overriding-header "Normal-priority tasks:")))
					(todo "NEXT" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "WAITING" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					(todo "TODO" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "SOMEDAY" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					)
				 ;; ((org-agenda-tag-filter-preset '("+@home")))
				 )
				))

(defun org-agenda-list-work ()
	(interactive)
	(org-agenda nil "w"))

(defun org-agenda-list-home ()
	(interactive)
	(org-agenda nil "h"))

(defun org-agenda-list-complete ()
	(interactive)
	(org-agenda nil "c"))

(define-key org-agenda-mode-map (kbd "W") 'org-agenda-list-work)
(define-key org-agenda-mode-map (kbd "H") 'org-agenda-list-home)
(define-key org-agenda-mode-map (kbd "C") 'org-agenda-list-complete)
#+END_SRC

Sort agenda TODOs with =org-agenda-sorting-strategy=.

Make the block agenda more compact:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-compact-blocks nil)
#+END_SRC

Change the separator between blocks in agenda:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-block-separator ?\-)
#+END_SRC

Start the weekly agenda today:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday nil)
#+END_SRC

Agenda remains open in background. No need to recompile it every time you call it:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-sticky t)
#+END_SRC

Show tags at the right edge of the screen:
#+BEGIN_SRC emacs-lisp
;; (setq org-agenda-tags-column (- (- (window-total-width) 3)))

;; taken from https://lists.gnu.org/archive/html/emacs-orgmode/2010-12/msg00410.html
(add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
(defun place-agenda-tags ()
  "Put the agenda tags by the right border of the agenda window."
  (setq org-agenda-tags-column (- 4 (window-width)))
  (org-agenda-align-tags))
#+END_SRC

Add the Emacs [[*Calendar/Diary][diary]] (which also stores holidays) to =org-agenda=:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-include-diary t) 
#+END_SRC

*** Images

Only use actual width of image when not specified with =#+ATTR* :width= (requires imagemagick)
#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width nil)
#+END_SRC

*** Links

Follow links when pressing =<return>=:
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

Add some link types:
#+BEGIN_SRC emacs-lisp
(setq org-link-abbrev-alist '(("att" . org-attach-expand-link)))
(setq org-link-abbrev-alist '(("attachment" . org-attach-expand-link)))
#+END_SRC

Links to files are opened in the same window, i.e. the window does not get split:
#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((file . find-file)))
#+END_SRC

Show whether links to files are valid:
#+BEGIN_SRC emacs-lisp
;; taken from https://emacs.stackexchange.com/a/33078/12336
(org-link-set-parameters
 "file"
 :face (lambda (path) (when (not (file-remote-p path))(if (file-exists-p path) 'org-link 'org-warning))))
#+END_SRC

Use IDs rather than headline names:
#+BEGIN_SRC emacs-lisp
(setq org-id-link-to-org-use-id t)
#+END_SRC

Use ID completion when generating ID links:
#+BEGIN_SRC emacs-lisp
;; taken from https://emacs.stackexchange.com/a/12434/12336
(defun org-id-complete-link (&optional arg)
  "Create an id: link using completion"
  (concat "id:"
          (org-id-get-with-outline-path-completion)))

(org-link-set-parameters "id"
                         :complete 'org-id-complete-link)
#+END_SRC

*** Tags

Tags can be set globally as default using the variable =org-tag-alist=. 
Tags can be set globally and permantly using the variable =org-tag-persistent-alist=. 

#+BEGIN_SRC emacs-lisp
(setq org-tag-persistent-alist
			'((:startgroup . nil)
				("@work" . ?w)
				(:grouptags . nil)
				("management" . ?m)
				("teaching" . ?t)
				("research" . ?r)
				("event" . ?e)
				(:endgroup . nil)

				(:startgroup . nil)
				("research" . ?r)
				(:grouptags . nil)
				("linguistics" . nil)
				("philosophy" . nil)
				("logic-maths" . nil)
				("cs" . nil)										; computer science
				("cl" . nil)										; computational linguistics
				(:endgroup . nil)

				(:startgroup . nil)
				("event" . ?e)
				(:grouptags . nil)
				("talk" . nil)									
				("workshop" . nil)
				("publication" . nil)
				("conference" . nil)
				("appointment" . ?a)
				(:endgroup . nil)

				(:startgroup . nil)
				("management" . ?m)
				(:grouptags . nil)
				("project" . nil)
				(:endgroup . nil)

				;; (:startgroup . nil)
				;; ("linguistics" . ?h)
				;; (:grouptags . nil)
				;; ("syntax" . nil)
				;; ("semantics" . nil)
				;; ("pragmatics" . nil)
				;; ("phonology" . nil)
				;; ("morphology" . nil)
				;; ("corpora" . nil)
				;; (:endgroup . nil)

				;; (:startgroup . nil)
				;; ("cl" . ?h)
				;; (:grouptags . nil)
				;; ("parsing" . nil)
				;; ("generation" . nil)
				;; ("formalisms" . nil)
				;; ("corpora" . nil)
				;; ("speechRecognition" . nil)
				;; ("machineLearning" . nil)
				;; (:endgroup . nil)

				(:startgroup . nil)
				("@home" . ?h)
				(:grouptags . nil)
				("spenden" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("software" . ?h)
				(:grouptags . nil)
				("programming" . nil)
				("nlp" . nil)
				("os" . nil)
				(:endgroup . nil)

				;; (:startgroup . nil)
				;; ("programming" . ?p)
				;; (:grouptags . nil)
				;; ("xmg" . nil)											
				;; ("emacs" . ?m)
				;; ("latex" . ?x)
				;; ("langsci" . ?l)
				;; ("python" . ?y)
				;; ("javascript" . ?j)
				;; ("perl" . nil)
				;; ("php" . nil)
				;; ("shellscript" . nil)											
				;; (:endgroup . nil)
				))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c :") 'org-set-tags)
#+END_SRC

*** Tables

Some functions to select and copy columns (http://emacs.stackexchange.com/a/28298/12336)
#+BEGIN_SRC emacs-lisp
(defun org-table-goto-col-beginning ()
  "Go to beginning of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (org-table-begin))
    (org-table-goto-column col))
  (point))

(defun org-table-col-beginning ()
  "Return beginning position of current column."
  (save-excursion
    (org-table-goto-col-beginning)))

(defun org-table-goto-col-end ()
  "Goto end of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (1- (org-table-end)))
    (org-table-goto-column col)
    (skip-chars-forward "^|"))
  (point))

(defun org-table-col-end ()
  "Return end position of current column."
  (save-excursion
    (org-table-goto-col-end)))

(defun org-table-select-col ()
  "Select current column."
  (interactive)
  (set-mark (org-table-col-beginning))
  (org-table-goto-col-end))

(defun org-table-copy-col ()
  "Copy current column."
  (interactive)
  (save-excursion
    (org-table-copy-region (org-table-goto-col-beginning)
													 (org-table-goto-col-end))))
#+END_SRC

Functions to move around single cells:
#+BEGIN_SRC emacs-lisp
(require 'org-table-move-single-cell)
#+END_SRC

*** Timestamps/Dates

#+BEGIN_SRC emacs-lisp
(defun tl/org-timestamp-dwim ()
	(interactive)
	(cond
	 ((use-region-p)
		(tl/org-read-date-and-insert-timestamp))
	 ((eq (org-at-timestamp-p 'inactive) 'bracket)
		(org-toggle-timestamp-type))
	 ((not (eq (org-at-timestamp-p 'inactive) 'bracket))
		(org-time-stamp nil))))

(define-key org-mode-map (kbd "C-c .") 'tl/org-timestamp-dwim)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun tl/org-read-date-and-insert-timestamp ()
	"Replace date in region with active timestamp"
	(interactive)
	(if (use-region-p)
			(let ((date (org-read-date nil nil (buffer-substring-no-properties (region-beginning) (region-end)))))
				(save-excursion
					(delete-region (region-beginning) (region-end))
					(goto-char (region-beginning))
					(insert "<" date ">")
					(org-ctrl-c-ctrl-c)))
		(message "No region selected")))
#+END_SRC

Set timestamp language to English:
#+BEGIN_SRC emacs-lisp
(setq system-time-locale "C")
#+END_SRC

*** Listings

Use the =listings= package:
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'listings)
#+END_SRC

Map scr-block languages to =listings= environments:
#+BEGIN_SRC emacs-lisp
;; (setq org-latex-custom-lang-environments
;; 			'((org-babel-language "listings-environment")))
#+END_SRC

*** Capture templates

- Template expansions: http://orgmode.org/manual/Template-expansion.html

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
			'(
				;; uses appointment tag
				("a" "Appointment" entry (file (lambda () (expand-file-name "captures.org" org-directory)))
				 "* %?\t%^G:appointment:\n\n%^T\n\n")
				;; ;; uses todo keyword APPT
				;; ("a" "Appointment" entry (file (lambda () (expand-file-name "captures.org" org-directory)))
				;; "* APPT %?\t%^G\n\n%^T\n\n")
				;; ;; used for org-gcal
				;; ("a" "Appointment" entry (file (concat org-directory "/gcal.org"))
				;;  "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
				("t" "Todo" entry (file (lambda () (expand-file-name "captures.org" org-directory)))
				 "* TODO %?\t%^G\n CREATED: %U\n About region:%i\n %a")
				("n" "Note" entry (file+datetree (lambda ()(expand-file-name "notes.org" org-directory)))
				 "* %?\t%^G\n CREATED: %U\n About region:%i\n %a")
				("c" "Code" entry (file (lambda () (expand-file-name "code.org" org-directory )))
				 "* %?\t%^G\n#+BEGIN_SRC %^{language}\n\n#+END_SRC\n CREATED: %U\n About region:%i\n %a")
				))

	;; (global-set-key (kbd "<f9> <f9>") 'org-capture)
	;; (global-set-key (kbd "<f9> <f9> t") (lambda () (interactive) (org-capture nil "t")))
#+END_SRC

*** PDF interaction

https://github.com/rudolfochrist/interleave

** Calendar/Diary

*** General settings

#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)

  (setq calendar-intermonth-text
        '(propertize
          (format "%2d"
                  (car
                   (calendar-iso-from-absolute
                    (calendar-absolute-from-gregorian (list month day year)))))
          'font-lock-face 'font-lock-warning-face))

  (setq calendar-intermonth-header
        (propertize "KW"                  ; or e.g. "KW" in Germany
                    'font-lock-face 'font-lock-keyword-face))
#+END_SRC

*** German holidays

#+BEGIN_SRC emacs-lisp
  (use-package german-holidays
    :ensure t
    :config
    (setq calendar-holidays holiday-german-holidays)
    ;; (setq calendar-holidays holiday-german-BW-holidays)
    )
#+END_SRC

*** calfw 

http://jameswilliams.be/blog/2016/01/11/Taming-Your-GCal.html

 #+BEGIN_SRC emacs-lisp
(use-package calfw
	:ensure t 
	:init

	(use-package calfw-org
		:ensure t)
	(use-package calfw-ical
		:ensure t)

	(setq cfw:render-line-breaker 'cfw:render-line-breaker-simple)

	(defvar user-calendar-settings-file
		(expand-file-name "calendar-calfw-settings.el" private-emacs-settings-dir))

	(if (file-exists-p user-calendar-settings-file)
			(load-file user-calendar-settings-file)
		(display-warning "calfw" (concat "Could not load " user-calendar-settings-file)))
	)

(define-key cfw:calendar-mode-map (kbd "u") 
	'(lambda () (interactive)
		 (when (fboundp 'tl/update-my-calendars) ; tl/update-my-calendars is defined in  user-calendar-settings-file
			 (tl/update-my-calendars))
		 (my-open-calfw)
		 ))

#+END_SRC

*** TODO COMMENT org-caldav

- [ ] Does not work with Horde CalDAV servers.

#+BEGIN_SRC emacs-lisp
(use-package org-caldav
  :ensure t
	:after (org org-agenda)
  :config (setq org-icalendar-timezone "Europe/Berlin"
								org-caldav-files nil
								org-caldav-backup-file (concat org-directory "org-caldav-backup.org")
								org-caldav-save-directory (concat org-directory "save/")
								org-caldav-delete-calendar-entries 'ask ; values: 'never 'ask
								;; for creating calendar events from org headings
								org-icalendar-include-todo t
								org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due)
								org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
	)
#+END_SRC


** LaTeX

*** TODO AUCTeX 

- [ ] How to do completion of custom macros?
  
#+BEGIN_SRC emacs-lisp
(use-package tex
	:ensure auctex												; because auctex overwrites tex
	:mode ("\\.bbx\\'" . latex-mode)("\\.cbx\\'" . latex-mode)
	:init

	;; to activate auctex
	(setq TeX-auto-save t)  
	(setq TeX-auto-local
				(expand-file-name "temp" user-emacs-directory))
	(setq TeX-parse-self t)
	(setq-default TeX-master nil)
	(setq TeX-save-query nil) ; autosave before compiling 

	;; Show compilation log
	(setq TeX-show-compilation nil) ; always show and follow TeX output
	;; FIXME: Make C-c C-l behave like this
	(setq compilation-scroll-output t)

	;; don't indent
	(setq LaTeX-indent-level 0)
	(setq LaTeX-item-indent 0)

	;; viewer
	(setq TeX-PDF-mode t)
	(setq TeX-source-correlate-mode t)
	(setq TeX-source-correlate-method 'synctex)

	(when (eq system-type 'windows-nt) 
		(setq TeX-view-program-list
					'(("Sumatra PDF" ("\"SumatraPDF.exe\" -reuse-instance"
														(mode-io-correlate " -forward-search %b %n ") " %o"))))
		(eval-after-load 'tex
			'(progn
				 (assq-delete-all 'output-pdf TeX-view-program-selection)
				 (add-to-list 'TeX-view-program-selection '(output-pdf "Sumatra PDF"))))
		)
	
	;; set up engines
	(setq TeX-engine-alist 
				'(
					(xetex "XeTeX" 
								 "xetex --file-line-error" 
								 "xelatex --file-line-error" 
								 "xetex")
					(xetex_sh "XeTeX shell escape" 
										"xetex --file-line-error --shell-escape" 
										"xelatex --file-line-error --shell-escape" 
										"xetex")))

	;; make LaTeXmk default
	(use-package auctex-latexmk
		:ensure t
		:config
		(auctex-latexmk-setup)
		(setq auctex-latexmk-inherit-TeX-PDF-mode t)
		(setq TeX-command-force "LatexMk")  ; remember to set path variable accordingly!
		)
	
	:config
	;; font keys
	(defun TeX-italic()
		(interactive)
		(TeX-font nil ?\C-i))
	(defun TeX-bold()
		(interactive)
		(TeX-font nil ?\C-b))
	(defun TeX-typewriter()
		(interactive)
		(TeX-font nil ?\C-t))
	(defun TeX-emphasis()
		(interactive)
		(TeX-font nil ?\C-e))
	(defun TeX-smallcaps()
		(interactive)
		(TeX-font nil ?\C-c))
	(defun TeX-italic-replace()
		(interactive)
		(TeX-font t ?\C-i))
	(defun TeX-bold-replace()
		(interactive)
		(TeX-font t ?\C-b))
	(defun TeX-typewriter-replace()
		(interactive)
		(TeX-font t ?\C-t))
	(defun TeX-emphasis-replace()
		(interactive)
		(TeX-font t ?\C-e))
	(defun TeX-smallcaps-replace()
		(interactive)
		(TeX-font t ?\C-c))
	(defun TeX-deletefont()
		(interactive)
		(TeX-font nil ?\C-d))
	(define-key LaTeX-mode-map (kbd "C-c C-f i") 'TeX-italic)
	(define-key LaTeX-mode-map (kbd "C-c C-f b") 'TeX-bold)
	(define-key LaTeX-mode-map (kbd "C-c C-f t") 'TeX-typewriter)
	(define-key LaTeX-mode-map (kbd "C-c C-f e") 'TeX-emphasis)
	(define-key LaTeX-mode-map (kbd "C-c C-f s") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c C-f c") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c C-f d") 'TeX-deletefont)	
	(define-key LaTeX-mode-map (kbd "C-c C-f DEL") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c f i") 'TeX-italic)
	(define-key LaTeX-mode-map (kbd "C-c f b") 'TeX-bold)
	(define-key LaTeX-mode-map (kbd "C-c f t") 'TeX-typewriter)
	(define-key LaTeX-mode-map (kbd "C-c f e") 'TeX-emphasis)
	(define-key LaTeX-mode-map (kbd "C-c f s") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c f c") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c f d") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c f DEL") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! i") 'TeX-italic-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! b") 'TeX-bold-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! t") 'TeX-typewriter-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! e") 'TeX-emphasis-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! s") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! c") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! i") 'TeX-italic-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! b") 'TeX-bold-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! t") 'TeX-typewriter-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! e") 'TeX-emphasis-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! s") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! c") 'TeX-smallcaps-replace)

	;; activate folding
	(add-hook 'LaTeX-mode-hook (lambda ()
															 (TeX-fold-mode 1)
															 ;; (TeX-fold-buffer)
															 ))
	;; folding behavior for environments
	(custom-set-variables '(TeX-fold-env-spec-list
													'(("[comment]" ("comment"))
														("[figure]" ("figure"))
														("[tikz]" ("tikzpicture")))))


	:bind (:map  LaTeX-mode-map
							 ;; ("C-l C-q" . align-current) ; useful command to align arrays
							 ;; ("C-l H-i" . align-current) ; useful command to align arrays							 
							 ;; keys for error browsing (disabled; see hydra settings)
							 ;; ("<f4>" . TeX-next-error)	 
							 ;; ("S-<f4>" . TeX-previous-error)
							 ;; ("C-<f4>" . TeX-error-overview)
							 ;; miscellaneous keys
							 ("C-c <backspace>" . TeX-clean)
							 ("C-<return>" . LaTeX-close-environment)
							 ;; goto keys
							 ("C-c {" . LaTeX-find-matching-begin)
							 ("C-c }" . LaTeX-find-matching-end)
							 ;; ("C-c C-l" . (lambda () (interactive) ()))  ;FIXME
							 )
	)
#+END_SRC

*** TODO reftex

- [ ] =\section=, =\frametitle= etc. are not shown in TOC when not being line-inital.

#+BEGIN_SRC emacs-lisp
(use-package reftex
	:diminish reftex-mode
	:init
	(add-hook 'latex-mode-hook 'turn-on-reftex)
	(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
	(setq reftex-plug-into-AUCTeX t
				;; reftex-ref-style-default-list '("Cleveref" "Hyperref" "Fancyref")
				;; reftex-toc-split-windows-horizontally t
				reftex-ref-macro-prompt nil			; go straight to the labels when referencing
				reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")
				reftex-default-bibliography (list user-bibliography-file)
				)

	;; add frametitle to TOC
	(setq reftex-section-levels '(("part" . 0)
																("chapter" . 1)
																("section" . 2)
																("subsection" . 3)
																("subsubsection" . 4)
																("frametitle" . -3)
																("paragraph" . 5)
																("subparagraph" . 6)
																("addchap" . -1)
																("addsec" . -2)))
	
	;; connect reftex to imenu
	(add-hook 'reftex-load-hook 'imenu-add-menubar-index)
	(add-hook 'reftex-mode-hook 'imenu-add-menubar-index)

	;; isearch across files
	(add-hook 'reftex-mode-hook  (lambda () (reftex-isearch-minor-mode)))
	
	:config
	
	;; jumping around like in org-mode
	(define-key LaTeX-mode-map (kbd "C-c C-j") 'tl/reftex-in-follow-mode)
	(define-key LaTeX-mode-map (kbd "C-n") 'tl/reftex-next)
	(define-key LaTeX-mode-map (kbd "C-p") 'tl/reftex-previous)
	(defun tl/reftex-in-follow-mode()
		(interactive)
		(setq reftex-toc-follow-mode t)
		(reftex-toc))
	(defun tl/reftex-next ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-next)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	(defun tl/reftex-previous ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-previous)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	
	:bind (:map LaTeX-mode-map
							("C-c ]" . reftex-citation); same as in org-mode
						  ) 
	)
#+END_SRC

*** bibtex

#+BEGIN_SRC emacs-lisp
(setq bibtex-dialect 'biblatex)
#+END_SRC

Align at equal sign instead of field text:
#+BEGIN_SRC emacs-lisp
(setq bibtex-align-at-equal-sign t)
#+END_SRC

Formatting:
#+BEGIN_SRC emacs-lisp
(setq bibtex-field-indentation 2
			bibtex-text-indentation 14
			bibtex-contline-indentation 15)
(add-hook 'bibtex-mode-hook (lambda () (set-fill-column 999))) ; don't fill column
#+END_SRC

Cleaning actions: 
#+BEGIN_SRC emacs-lisp
(setq bibtex-entry-format
			'(opts-or-alts ; delete empty optional and alternative fields
				required-fields ; signal an error if a required field is missing.
				numerical-fields ; delete delimiters around numeral fields
				inherit-booktitle ; insert booktitle if it is in the crossref
				realign						; realign entries
				last-comma				; add or delete last comma
				delimiters				; change delimiters 
				unify-case				; change case of entry types and field names
				sort-fields
				)) 							
#+END_SRC

Key generation:
#+BEGIN_SRC emacs-lisp
(setq
 ;; name part
 bibtex-autokey-names 2						; maximal number of names used
 bibtex-autokey-preserve-case t		
 bibtex-autokey-name-separator ":" 
 ;; year part
 bibtex-autokey-year-length 2 			; size of year part (from the right)
 bibtex-autokey-name-year-separator ":" 
 bibtex-autokey-year-use-crossref-entry t ; use year from crossref (depends on bibtex-maintain-sorted-entries)
;; title part
 bibtex-autokey-titleword-length 0			; number of used titlewords
)
#+END_SRC

Sorting entries:
#+BEGIN_SRC emacs-lisp
(setq bibtex-maintain-sorted-entries t)
#+END_SRC

**** import

Taken from http://www.anghyflawn.net/blog/2014/emacs-give-a-doi-get-a-bibtex-entry/:

#+BEGIN_SRC emacs-lisp
(defun get-bibtex-from-doi (doi)
 "Get a BibTeX entry from the DOI"
 (interactive "MDOI: ")
 (let ((url-mime-accept-string "text/bibliography;style=bibtex"))
   (with-current-buffer 
     (url-retrieve-synchronously 
       (format "http://dx.doi.org/%s" 
       	(replace-regexp-in-string "http://dx.doi.org/" "" doi)))
     (switch-to-buffer (current-buffer))
     (goto-char (point-max))
     (setq bibtex-entry 
     	  (buffer-substring 
          	(string-match "@" (buffer-string))
              (point)))
     (kill-buffer (current-buffer))))
 (insert (decode-coding-string bibtex-entry 'utf-8))
 (bibtex-fill-entry))
#+END_SRC

**** entry templates

#+BEGIN_QUOTE
Documentation of bibtex-entry-field-alist:
Alist of BibTeX entry types and their associated fields.
Elements are lists (ENTRY-TYPE DOC REQUIRED CROSSREF OPTIONAL).
ENTRY-TYPE is the type of a BibTeX entry.
DOC is a brief doc string used for menus. If nil ENTRY-TYPE is used.
REQUIRED is a list of required fields.
CROSSREF is a list of fields that are optional if a crossref field
is present; but these fields are required otherwise.
OPTIONAL is a list of optional fields.

Each element of these lists is a list of the form
  (FIELD COMMENT INIT ALTERNATIVE).
COMMENT, INIT, and ALTERNATIVE are optional.

FIELD is the name of the field.
COMMENT is the comment string that appears in the echo area.
If COMMENT is nil use ‘bibtex-BibTeX-field-alist’ if possible.
INIT is either the initial content of the field or a function,
which is called to determine the initial content of the field.
ALTERNATIVE if non-nil is an integer that numbers sets of
alternatives, starting from zero.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(defvar bibtex-langsci-entry-alist 
	`(("Article" "Article in Journal"
		 ;; required
		 (("author")
			("title" "Title of the article (BibTeX converts it to lowercase)"))
		 ;; required without crossref
		 (("journal")
			("year"))
		 ;; optional
		 (("volume" "Volume of the journal")
			("number" "Number of the journal (only allowed if entry contains volume)")
			("pages" "Pages in the journal")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))

		("Book" "Book"
		 ;; required
		 (("author" nil nil 0)
			("editor" nil nil 0)
			("title" nil nil 1)
			("booktitle" nil nil 1)
			("year")
			("publisher")
			("address"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("volume" "Volume of the book in the series")
			("number" "Number of the book in a small series (overwritten by volume)")
			("series" "Series in which the book appeared")
			("edition" "Edition of the book as a capitalized English word")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))

		("Collection" "Collection"
		 ;; required
		 (("editor")
			("booktitle")
			("year")
			("publisher")
			("address"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("title")
			("volume" "Volume of the book in the series")
			("number" "Number of the book in a small series (overwritten by volume)")
			("series" "Series in which the book appeared")
			("edition" "Edition of the book as a capitalized English word")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))

		("Proceedings" "Conference Proceedings"
		 ;; required
		 (("booktitle")
			("year"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("editor")
			("title")
			("volume" "Volume of the conference proceedings in the series")
			("number" "Number of the conference proceedings in a small series (overwritten by volume)")
			("series" "Series in which the conference proceedings appeared")
			("address")
			("organization" "Sponsoring organization of the conference")
			("publisher" "Publishing company, its location")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))

		("InProceedings" "Article in Conference Proceedings"
		 ;; required
		 (("author")
			("title" "Title of the article in proceedings (BibTeX converts it to lowercase)")
			("pages" "Pages in the conference proceedings"))
		 ;; required without crossref
		 (("booktitle" "Name of the conference proceedings")
			("year"))
		 ;; optional
		 (("editor")
			("volume" "Volume of the conference proceedings in the series")
			("number" "Number of the conference proceedings in a small series (overwritten by volume)")
			("series" "Series in which the conference proceedings appeared")
			("publisher" "Publishing company, its location")
			("address")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))

		("InCollection" "Article in a Collection"
		 ;; required
		 (("author")
			("title" "Title of the article in proceedings (BibTeX converts it to lowercase)")
			("pages" "Pages in the conference proceedings"))
		 ;; required without crossref
		 (("booktitle" "Name of the conference proceedings")
			("editor")
			("address")
			("publisher" "Publishing company, its location")
			("year"))
		 ;; optional
		 (("volume" "Volume of the conference proceedings in the series")
			("number" "Number of the conference proceedings in a small series (overwritten by volume)")
			("series" "Series in which the conference proceedings appeared")
			("chapter")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))
		
		("Thesis" "Thesis"
		 ;; required
		 (("author")
			("title" "Title of the thesis")
			("type" "Type of the thesis")
			("school" "School where the thesis was written")
			("address")
			("year"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))
		
		("TechReport" "Technical Report"
		 ;; required
		 (("author")
			("title" "Title of the technical report (BibTeX converts it to lowercase)")
			("year")
			("address")
			("publisher"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("number" "Number of the technical report")
			("series")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))
		
		("Online" "Online resource"
		 ;; required
		 (("title" "Title of the online resource")
			("author")
			("year")
			("url")
			("urldate"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("doi")
			("booktitle")
			("editor")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note")))
		
		("Unpublished" "Unpublished"
		 ;; required
		 (("author")
			("title" "Title of the unpublished work (BibTeX converts it to lowercase)")
			("note"))
		 ;; required without crossref
		 nil
		 ;; optional
		 (("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			))
		
		("Misc" "Miscellaneous"
		 ;; required
		 nil
		 ;; required without crossref
		 nil
		 ;; optional
		 (("author")
			("editor")
			("title")
			("booktitle")
			("journal")
			("edition")
			("series")
			("volume")
			("number")
			("pages")
			("chapter")
			("address")
			("publisher")
			("school")
			("type")
			("year")
			("url")
			("urldate")
			("doi")
			("timestamp" nil ,(format-time-string "%Y-%m-%d" (current-time)))
			("note"))))
	"Entry types following the formatting rules of Language Science Press (https://github.com/langsci/bib-db)."
	)
#+END_SRC

Activate langsci dialect:
#+BEGIN_SRC emacs-lisp
(defvar bibtex-langsci-field-alist bibtex-biblatex-field-alist)
(add-to-list 'bibtex-langsci-field-alist '("timestamp" "Date of creation or modification of the entry."))

(add-to-list 'bibtex-dialect-list 'langsci)
(setq bibtex-dialect 'langsci)
#+END_SRC

Function to add timestamp:
#+BEGIN_SRC emacs-lisp
(defun tl/bibtex-add-timestamp ()
	(interactive)
	(bibtex-set-field "timestamp" (format-time-string "%Y-%m-%d" (current-time))) 
)
#+END_SRC

Use =bibtex-entry= when inserting entry templates:
#+BEGIN_SRC emacs-lisp
(define-key bibtex-mode-map (kbd "C-c C-e") 'bibtex-entry)
#+END_SRC

*** helm-bibtex

Search through your BibTeX bibliography with helm. 

#+BEGIN_SRC emacs-lisp
(use-package helm-bibtex
	:ensure t
	:config
	(setq bibtex-completion-bibliography (list user-bibliography-file))
	(setq bibtex-completion-additional-search-fields '(bibtexkey))
	;; The standard function with modified default action  
	;; :bind (:map LaTeX-mode-map ("C-l C-r" . helm-bibtex-with-local-bibliography))
	
	(helm-delete-action-from-source "Open PDF, URL or DOI" helm-source-bibtex)
	(helm-delete-action-from-source "Open PDF file (if present)" helm-source-bibtex)
	(helm-delete-action-from-source "Open URL or DOI in browser" helm-source-bibtex)
	(helm-delete-action-from-source "Show entry" helm-source-bibtex)
	
	(helm-add-action-to-source "Show entry"
														 'bibtex-completion-show-entry
														 helm-source-bibtex 5)
	(helm-add-action-to-source "Open PDF, URL or DOI"
														 'bibtex-completion-open-any
														 helm-source-bibtex 6)
	(helm-add-action-to-source "Open PDF file (if present)"
														 'bibtex-completion-open-pdf
														 helm-source-bibtex 7)
	(helm-add-action-to-source "Open URL or DOI in browser"
														 'bibtex-completion-open-url-or-doi
														 helm-source-bibtex 8)

	;; Temporarily move "Show entry" to the first position of the action list when in bibtex-mode
	(defun tl/promote_show_entry (&optional arg local-bib)
		(helm-delete-action-from-source "Show entry" helm-source-bibtex)
		(helm-add-action-to-source "Show entry"
															 'bibtex-completion-show-entry
															 helm-source-bibtex 0))
	(defun tl/demote_show_entry (&optional arg local-bib)
		(helm-delete-action-from-source "Show entry" helm-source-bibtex)
		(helm-add-action-to-source "Show entry"
															 'bibtex-completion-show-entry
															 helm-source-bibtex 5))
	(defun tl/helm-bibtex-in-bibtex-mode ()
		(interactive)
		(tl/promote_show_entry)
		(helm-bibtex)
		(tl/demote_show_entry))
	(define-key bibtex-mode-map (kbd "C-c h") 'tl/helm-bibtex-in-bibtex-mode)
	(define-key bibtex-mode-map (kbd "C-c C-h") 'tl/helm-bibtex-in-bibtex-mode)
	
	(advice-add 'bibtex-completion-candidates :filter-return 'reverse)

	(setq bibtex-completion-display-formats 
				'((t . "${author:36} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${=type=:7}")))
	)
#+END_SRC

*** COMMENT ivy-bibtex

#+BEGIN_SRC emacs-lisp
		;; ;; ivy-bibtex
		;; (use-package ivy-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; (define-key LaTeX-mode-map (kbd "C-l C-r") 'ivy-bibtex)
		;; 	;; The standard function with modified default action  
		;; 	(defun ivy-bibtex (&optional arg)
		;; 		"Search BibTeX entries using ivy. With a prefix ARG the cache is invalidated and the bibliography reread."
		;; 		(interactive "P")
		;; 		(when arg
		;; 			(setq bibtex-completion-bibliography-hash ""))
		;; 		(bibtex-completion-init)
		;; 		(ivy-read "BibTeX Items: "
		;; 							(bibtex-completion-candidates 'ivy-bibtex-candidates-formatter)
		;; 							:caller 'ivy-bibtex
		;; 							:action 'bibtex-completion-insert-key))
		;; 	;; look for local bibliographies
		;; 	;; (require 'ebib)
		;; 	(defun ivy-bibtex-with-local-bibliography ()
		;;     (interactive)
		;;     (let ((bibtex-completion-bibliography
		;; 					 (if (eq major-mode 'latex-mode)
		;; 							 ;; (ebib--get-local-databases)
		;; 							 (bibtex-completion--get-local-databases)
		;; 						 bibtex-completion-bibliography)))
		;; 			(ivy-bibtex)))
		;; 	;; proposal by jagrg: https://github.com/tmalsburg/helm-bibtex/issues/112 
		;; 	(defun bibtex-completion--get-local-databases ()
		;; 		"Return a list of .bib files associated with the current file."
		;; 		(let ((texfile nil)
		;; 					(cb (current-buffer)))
		;; 			(when (and (boundp 'TeX-master)
		;; 								 (stringp TeX-master))
		;; 				(setq texfile (if (file-name-extension TeX-master)
		;; 													TeX-master
		;; 												(concat TeX-master ".tex"))))
		;; 			(with-temp-buffer
		;; 				(if (and texfile (file-readable-p texfile))
		;; 						(insert-file-contents texfile)
		;; 					(insert-buffer-substring cb))
		;; 				(save-match-data
		;; 					(goto-char (point-min))
		;; 					(cond
		;; 					 ;; bibtex
		;; 					 ((re-search-forward "\\\\\\(?:no\\)*bibliography{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(split-string (match-string-no-properties 1) ",[ ]*")))
		;; 					 ;; biblatex
		;; 					 ((re-search-forward "\\\\addbibresource\\(\\[.*?\\]\\)?{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(let ((option (match-string 1))
		;; 													(file (match-string-no-properties 2)))
		;; 											(unless (and option (string-match-p "location=remote" option))
		;; 												(split-string file ",[ ]*")))))
		;; 					 (t
		;; 						bibtex-completion-bibliography))))))
		;; 	:bind (:map LaTeX-mode-map 
		;; 							("C-l C-r" . ivy-bibtex-with-local-bibliography))
		;; 	)
#+END_SRC

*** Beamer
:LOGBOOK:
- Note taken on [2017-11-13 Mo 10:07] \\
  Add =\begin{frame}=  to outline (and imenu):
  #+BEGIN_SRC emacs-lisp
  (add-to-list 'TeX-outline-extra '("\\\\begin{frame}\\(\\[.*\\]\\)?" 4))
  #+END_SRC
  FIXME: Does not show the title.
:END:

Add =\frametitle= to outline (and imenu):
#+BEGIN_SRC emacs-lisp
(add-to-list 'TeX-outline-extra '("\\\\frametitle\\b" 4))
#+END_SRC

*** Misc

Make square brackets indent correctly (testing):
#+BEGIN_SRC emacs-lisp
;; (modify-syntax-entry ?\[ "(]" LaTeX-mode-syntax-table)
;; (modify-syntax-entry ?\] ")[" LaTeX-mode-syntax-table)

;; Proposed by https://emacs.stackexchange.com/a/35507/12336
;; Overwrites TeX-brace-count-line from tex.el
(defun TeX-brace-count-line ()
  "Count number of open/closed braces."
  (save-excursion
    (let ((count 0) (limit (line-end-position)) char)
      (while (progn
               (skip-chars-forward "^{}[]\\\\" limit)
               (when (and (< (point) limit) (not (TeX-in-comment)))
                 (setq char (char-after))
                 (forward-char)
                 (cond ((eq char ?\{)
                        (setq count (+ count TeX-brace-indent-level)))
                       ((eq char ?\})
                        (setq count (- count TeX-brace-indent-level)))
                       ((eq char ?\[)
                        (setq count (+ count TeX-brace-indent-level)))
                       ((eq char ?\])
                        (setq count (- count TeX-brace-indent-level)))
                       ((eq char ?\\)
                        (when (< (point) limit)
                          (forward-char)
                          t))))))
      count)))
#+END_SRC

Delete macro at point (http://emacs.stackexchange.com/a/7997/12336):
#+BEGIN_SRC emacs-lisp
(defun TeX-delete-macro ()
  "Remove current macro and return `t'.  If no macro at point,
return `nil'."
  (interactive)
  (when (TeX-current-macro)
    (let ((bounds (TeX-find-macro-boundaries))
          (brace  (save-excursion
                    (goto-char (1- (TeX-find-macro-end)))
                    (TeX-find-opening-brace))))
      (delete-region (1- (cdr bounds)) (cdr bounds))
      (delete-region (car bounds) (1+ brace)))
    t))
#+END_SRC

Delete environment at point (https://www.reddit.com/r/emacs/comments/5f99nv/help_with_auctex_how_to_delete_an_environment/dailbtu/):
#+BEGIN_SRC emacs-lisp
(defun TeX-delete-environment ()
  (interactive)
  (when (LaTeX-current-environment)
    (save-excursion
      (let* ((begin-start (save-excursion
                            (LaTeX-find-matching-begin)
                            (point)))
             (begin-end (save-excursion
                          (goto-char begin-start)
                          (search-forward-regexp "begin{.*?}")))
             (end-end (save-excursion
                        (LaTeX-find-matching-end)
                        (point)))
             (end-start (save-excursion
                          (goto-char end-end)
                          (1- (search-backward-regexp "\\end")))))
        ;; delete end first since if we delete begin first it shifts the
        ;; location of end
        (delete-region end-start end-end)
        (delete-region begin-start begin-end)))))
#+END_SRC

<tab> should always insert a tab (instead of indentation):
#+BEGIN_SRC emacs-lisp
	(add-hook 'LaTeX-mode-hook '(lambda () (setq-local tab-always-indent nil)))
#+END_SRC

Usefull extras, e.g., org-mode-like folding:
#+BEGIN_SRC emacs-lisp
(use-package latex-extra                
  :ensure t
  :defer t
  :config (add-hook 'LaTeX-mode-hook #'latex-extra-mode))
#+END_SRC 

** Ledger

[[http://ledger-cli.org][Ledger]] is a powerful, double-entry accounting system.

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
	:ensure t
  :mode ("\\.ledger\\'" "\\.dat\\'")
  :config
  (define-key ledger-mode-map (kbd "C-c c") 'ledger-mode-clean-buffer)
  (define-key ledger-mode-map (kbd "C-<tab>") nil)
  (setq ledger-post-amount-alignment-at :decimal
        ledger-post-amount-alignment-column 49
				ledger-default-date-format "%Y-%m-%d"
				ledger-use-iso-dates t
				ledger-reconcile-default-commodity "€"
        ledger-clear-whole-transactions t)
  (use-package flycheck-ledger
		:ensure t))
#+END_SRC

** Markdown

*** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown")
	:config	(setq markdown-enable-math t))
#+END_SRC

*** markdown-toc

#+BEGIN_SRC emacs-lisp
(use-package markdown-toc
	:ensure t)
#+END_SRC

** R

*** ess

- [ ] "Error (use-package): ess :init: Cannot open load file: No such file or directory, julia-mode"
- [X] "Error (use-package): ess/:init: Recursive ‘require’ for feature ‘ess-r-mode’"

=ess= (Emacs Speaks Statistics) is the package that integrates R into Emacs.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t
  :init (require 'ess-site))
#+END_SRC

** Deft

#+BEGIN_SRC emacs-lisp
(use-package deft												; for displaying list of note files
	:ensure t
  :bind
	("<f9> o" . deft)
	("<f9> d" . deft)
  :commands (deft)
  :config (setq deft-directory my-deft-dir
                deft-extensions '("md" "org")
								deft-recursive t
								deft-use-filename-as-title t
								deft-use-filter-string-for-filename t))
#+END_SRC

** Pomodoro technique

*** COMMENT tomatinho

Tomatinho brings the promodoro technique to Emacs. I prefer pomidor though.

#+BEGIN_SRC emacs-lisp
(use-package tomatinho
	:ensure t
	)
#+END_SRC

*** pomidor

Pomidor brings the promodoro technique to Emacs:
#+BEGIN_SRC emacs-lisp
(use-package pomidor
	:ensure t
	:init
	(setq pomidor-sound-tick nil
				pomidor-sound-tack nil
				pomidor-sound-overwork t)
	)
#+END_SRC

** EPUB reader

https://github.com/wasamasa/nov.el

** RSS/Atom feed reader 

*** elfeed

Largely taken from http://cestlaz.github.io/posts/using-emacs-29%20elfeed/.
Feed collections can be converted to the format of =elfeed-org= with the function =elfeed-org-import-opml=.

#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :ensure t
  :bind (:map elfeed-search-mode-map
							("q" . bjm/elfeed-save-db-and-bury)
							("Q" . bjm/elfeed-save-db-and-bury)
							("m" . elfeed-toggle-star)
							("M" . tl/elfeed-show-starred)
							("R" . elfeed-mark-all-as-read)
							("U" . tl/elfeed-show-unread)
							("s" . bjm/elfeed-search-live-filter-space)
							("f" . bjm/elfeed-search-live-filter-space)
							("*" . tl/elfeed-show-starred)
							("/" . mz/make-and-run-elfeed-hydra)
							("A" . tl/elfeed-show-all)
							)
	:config
	(when (boundp 'my-elfeed-db-directory)
		(setq elfeed-db-directory my-elfeed-db-directory))
	(defalias 'elfeed-toggle-star
		(elfeed-expose #'elfeed-search-toggle-all 'star))

	(defface star-elfeed-entry
		'((t :foreground "#f77"))
		"Marks an starred Elfeed entry.")
	(push '(star star-elfeed-entry)
				elfeed-search-face-alist)

	(defun elfeed-mark-all-as-read ()
		(interactive)
		(mark-whole-buffer)
		(elfeed-search-untag-all-unread))

	(defun tl/elfeed-show-starred ()
		(interactive)
		(elfeed-search-set-filter "@6-months-ago +star"))
	
	(defun tl/elfeed-show-all ()
		(interactive)
		(elfeed-search-set-filter "@6-months-ago"))

	(defun tl/elfeed-show-unread ()
		(interactive)
		(elfeed-search-set-filter "@6-months-ago +unread"))

	;;functions to support syncing .elfeed between machines
	;;makes sure elfeed reads index from disk before launching
	(defun bjm/elfeed-load-db-and-open ()
		"Wrapper to load the elfeed db from disk before opening"
		(interactive)
		(elfeed-db-load)
		(elfeed)
		(elfeed-search-update--force))

	;;write to disk when quiting
	(defun bjm/elfeed-save-db-and-bury ()
		"Wrapper to save the elfeed db to disk before burying buffer"
		(interactive)
		(elfeed-db-save)
		(quit-window))

	;;insert space before elfeed filter
	(defun bjm/elfeed-search-live-filter-space ()
		"Insert space when running elfeed filter"
		(interactive)
		(let ((elfeed-search-filter (concat elfeed-search-filter " ")))
			(elfeed-search-live-filter)))

	(use-package elfeed-goodies
		:ensure t
		:config
		(elfeed-goodies/setup)
		(setq elfeed-goodies/entry-pane-size 0.75
					elfeed-goodies/entry-pane-position 'bottom))

	(use-package elfeed-org
		:ensure t
		:config
		(elfeed-org)
		(when (boundp 'my-elfeed-org-file)
			(setq rmh-elfeed-org-files (list my-elfeed-org-file)))
		(setq rmh-elfeed-org-auto-ignore-invalid-feeds nil)) ; handle with care

	)
#+END_SRC

Wrapper function for elfeed (used in [[*hydra-f7][hydra-f7]]):

#+BEGIN_SRC emacs-lisp
(defun tl/elfeed ()
	(interactive)
	(elfeed)
	(visual-line-mode -1))
#+END_SRC

Generate filter hydra for a given set of tags (using code macros).
Taken from http://cestlaz.github.io/posts/using-emacs-31-elfeed-3/.

#+BEGIN_SRC emacs-lisp
(defun z/hasCap (s) 
	""
	(let ((case-fold-search nil))
				 (string-match-p "[[:upper:]]" s)
				 ))

(defun z/get-hydra-option-key (s)
  "returns single upper case letter (converted to lower) or first"
  (interactive)
  (let ( (loc (z/hasCap s)))
    (if loc
				(downcase (substring s loc (+ loc 1)))
      (substring s 0 1)
			)))

(defun mz/make-elfeed-cats (tags)
  "Returns a list of lists. Each one is line for the hydra configuratio in the form
     (c function hint)"
  (interactive)
  (mapcar (lambda (tag)
						(let* (
									 (tagstring (symbol-name tag))
									 (c (z/get-hydra-option-key tagstring))
									 )
							(list c (append '(elfeed-search-set-filter) (list (format "@6-months-ago +%s" tagstring) ))tagstring  )))
					tags))

(defmacro mz/make-elfeed-hydra ()
  `(defhydra mz/hydra-elfeed ()
     "filter"
     ,@(mz/make-elfeed-cats (elfeed-db-get-all-tags))
     ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
     ;; ("M" elfeed-toggle-star "Mark")
     ("A" (elfeed-search-set-filter "@6-months-ago") "All")
     ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
     ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
     ("q" nil "quit" :color blue)
     ))

(defun mz/make-and-run-elfeed-hydra ()
  ""
  (interactive)
  (mz/make-elfeed-hydra)
  (mz/hydra-elfeed/body))

#+END_SRC

** XMG

#+BEGIN_SRC emacs-lisp
(require 'xmg-mode) 
#+END_SRC

** PDF

*** COMMENT pdf-tools

The hard part is to generate =epdfinfo.exe= under Windows. Therefore I'm not using it.

https://github.com/politza/pdf-tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
	:ensure t
	;; :if (executable-find "epdfinfo")
	:mode (("\\.pdf\\'" . pdf-view-mode))
	:config
	(setq-default pdf-view-display-size 'fit-page) ; fit page by default
	(setq pdf-view-resize-factor 1.10)
	;; (pdf-tools-install)
	;; (setq pdf-info-epdfinfo-program (expand-file-name "epdinfo.exe" (concat wemacs-dir "pdftools")))
)
#+END_SRC

*** COMMENT bibliothek

Nice idea, but it currently does not work because of "damaged" PDFs in my collection. 
Depends on =pdf-tools=.

https://github.com/cadadr/elisp#bibliothekel

#+BEGIN_SRC emacs-lisp
(use-package bibliothek
	:ensure t
	:if (executable-find "epdfinfo")
	:config
	(setq bibliothek-path (list user-bibliography-pdf-dir)))
#+END_SRC

*** COMMENT interleave

For taking notes in =org-mode= side by side with the PDF.
Depends on =pdf-tools=.

#+BEGIN_SRC emacs-lisp
(use-package interleave
  :ensure t
  :bind ("C-x i" . interleave-mode)
  :config
  (setq interleave-split-direction 'horizontal
        interleave-split-lines 20
        interleave-disable-narrowing t))
#+END_SRC

** Email

Offlineimap or mbsync? http://pragmaticemacs.com/emacs/migrating-from-offlineimap-to-mbsync-for-mu4e/

*** COMMENT mu4e

- incompatible with windows?
  - Drafts are saved with incompatible file names (including colons).

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp/mu4e" user-emacs-directory))
(require 'mu4e)
(setq mu4e-mu-binary (expand-file-name "mu/mu.bat" wemacs-dir)
			mu4e-maildir (expand-file-name "Maildir" home-directory)) 
#+END_SRC

*** COMMENT notmuch

Idea: offlineimap and notmuch are running in a WSL where also the maildir is located. Emacs calls notmuch from outside to search and obtain mails from the WSL maildir.

- [X] install offlinimap and notmuch in the WSL
- [X] write shell script to call notmuch from windows (=remote-notmuch.bat=)
- [ ] BUG: search and display of mail not working ("Spawning child process: Invalid argument"); seems to be a problem with shell.el
- [ ] configure offlineimap to invoke notmuch on changes in maildir
- [ ] start offlineimap when starting notmuch in emacs.
- [ ] configure smtp

https://wwwtech.de/articles/2016/jul/my-personal-mail-setup
https://notmuchmail.org/remoteusage/
https://kkatsuyuki.github.io/notmuch-conf/
https://admiralakber.github.io/2018/09/20/myos-email/

#+BEGIN_SRC emacs-lisp
(use-package notmuch
	:ensure t
	:config
	(setq notmuch-command "remote-notmuch.bat")) ; make sure this is in your PATH variable
#+END_SRC

** gtypist

GNU Typist: An interactive typing tutor
https://www.gnu.org/software/gtypist/doc/gtypist.html

Unfortunately, there doesn't seem to be an easy way to run this within Emacs (at least under Windows).

* Minor modes
** pandoc-mode

[[http://joostkremers.github.io/pandoc-mode/][pandoc-mode]] allows one to use =pandoc= from within Emacs. =pandoc= is a very rich transducer for text formats. Note that =pandoc= needs to be installed separately.

#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
	:ensure t
  :config
  ;; (add-hook 'markdown-mode-hook 'pandoc-mode)
  ;; (add-hook 'org-mode-hook 'pandoc-mode)
  (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings))
#+END_SRC

* Buffer

** General configuration

Automatically update buffers when files change:
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+end_src

Visible bell:
#+begin_src emacs-lisp
(setq visible-bell t)
(setq ring-bell-function (lambda ()
                           (invert-face 'mode-line)
                           (run-with-timer 0.05 nil 'invert-face 'mode-line)))
#+end_src

Delete marked text on typing:
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Use tabs for indent:
#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode t)
#+end_src

Scrolling:
#+begin_src emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000)
;; autoscroll compilation output
(setq compilation-scroll-output t)
;; scroll to the first/last line
(setq scroll-error-top-bottom t)
#+end_src

Show vertical line per indentation level: 
#+begin_src emacs-lisp
(use-package highlight-indent-guides
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
	(setq highlight-indent-guides-method 'character)
	)
#+end_src

** Autocomplete

*** yasnippet (before auto-complete)

#+begin_src emacs-lisp
(use-package yasnippet
	:ensure t
	:config 
	(yas-global-mode 1)
	(add-to-list 'warning-suppress-types '(yasnippet backquote-change)))
#+end_src

*** auto-complete
Sequence is important!

#+begin_src emacs-lisp
;; (require 'auto-complete)
;; (require 'auto-complete-auctex)
;; (require 'auto-complete-config)
;; (ac-config-default)
;; (setq ac-auto-show-menu t)
;; (setq ac-auto-show-menu 1)
;; (global-auto-complete-mode 1)
;; ;; (add-to-list 'ac-modes 'latex-mode)     ; activate auto-complete for latex <modes (AUCTeX or Emacs' builtin one).
;; (add-hook 'latex-mode-hook (function (lambda ()
;; 																					(ac-source-yasnippet))))
#+end_src

*** TODO company

- [ ] completion of LaTeX code in AUCTex
- [ ] completion in org-mode of LaTeX code

**** General settings

#+begin_src emacs-lisp
(use-package company
	:ensure t
	:config

	;; some general variables
	(setq company-idle-delay 0.2
				company-minimum-prefix-length 1
				company-selection-wrap-around t
				company-tooltip-flip-when-above t
				;; company-show-numbers t
				company-dabbrev-downcase nil
				company-auto-complete nil
				company-tooltip-align-annotations t
				company-transformers '(company-sort-by-occurrence))

	;; keys
	(eval-after-load 'company
	  '(progn
	     (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
			 (define-key company-active-map (kbd "<return>") nil)
			 (define-key company-active-map (kbd "RET") nil)
	     ;; (define-key company-active-map (kbd "<tab>") 'company-complete-common)  ; Insert the common part of all candidates.  
	     ;; (define-key company-active-map (kbd "<tab>") 'company-select-next))
			 (define-key company-active-map (kbd "<up>") 'company-select-previous)
			 (define-key company-active-map (kbd "<down>") 'company-select-next)
			 ))
	
  ;; activate global-company-mode
	(add-hook 'after-init-hook 'global-company-mode)
	)
#+end_src

Add fuzzy matching capabilities:

#+begin_src emacs-lisp
(use-package company-flx
	:ensure t
	:config
	(with-eval-after-load 'company
		(company-flx-mode +1)))
#+end_src

When =company= is actively used by browsing completion candidates, =<return>= should execute the selected completion.

#+BEGIN_SRC emacs-lisp
;; Taken from https://github.com/company-mode/company-mode/issues/530.
(defun my-company-active-return ()
	(interactive)
	(if (company-explicit-action-p)
			(company-complete)
		(call-interactively
		 (or (key-binding (this-command-keys))
				 (key-binding (kbd "RET")))
		 )))

(define-key company-active-map (kbd "<return>") #'my-company-active-return)
(define-key company-active-map (kbd "RET") #'my-company-active-return)
#+END_SRC

**** Math symbols

#+BEGIN_SRC emacs-lisp
(use-package company-math
	:ensure t
	:config
	;; (add-to-list 'company-backends 'company-math-symbols-unicode) ; insert unicode symbol
	(add-to-list 'company-backends 'company-math-symbols-latex) ; insert LaTeX code
	)
#+END_SRC

**** LaTeX
  
  #+begin_src emacs-lisp
(use-package company-auctex
	:ensure t
	:config (company-auctex-init))
#+end_src

**** RefTeX

#+BEGIN_SRC emacs-lisp
(use-package company-reftex
	:ensure t
	:config
	(add-to-list 'company-backends 'company-reftex-labels) 
	(add-to-list 'company-backends 'company-reftex-citations) 
	)
#+END_SRC

**** COMMENT eshell

Unfortunately, this really slows down eshell a lot.

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook '(lambda () (setq company-idle-delay 0)))
#+end_src

**** org-mode

#+begin_src emacs-lisp
(add-to-list 'company-backends 'company-capf)
(defun add-pcomplete-to-capf ()
	(add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
#+end_src

Add easy templates to company (https://emacs.stackexchange.com/a/33487/12336):
#+BEGIN_SRC emacs-lisp
(defun org-easy-template--completion-table (str pred action)
  (pcase action
    (`nil (try-completion  str org-structure-template-alist pred))
    (`t   (all-completions str org-structure-template-alist pred))))

(defun org-easy-template--annotation-function (s)
  (format " -> %s" (cadr (assoc s org-structure-template-alist))))

(defun org-easy-template-completion-function ()
  (when (looking-back "^[ \t]*<\\([^ \t]*\\)" (point-at-bol))
    (list
     (match-beginning 1) (point)
     'org-easy-template--completion-table
     :annotation-function 'org-easy-template--annotation-function
     :exclusive 'no)))

(defun add-easy-templates-to-capf ()
	(add-hook 'completion-at-point-functions 'org-easy-template-completion-function nil t))
(add-hook 'org-mode-hook #'add-easy-templates-to-capf)

#+END_SRC

**** yasnippet

Execute when all backends added to =company-backends=.

#+begin_src emacs-lisp
(defvar company-mode/enable-yas t
	"Enable yasnippet for all backends.")
(defun company-mode/backend-with-yas (backend)
	(if (or (not company-mode/enable-yas)
					(and (listp backend) (member 'company-yasnippet backend)))
			backend
		(append (if (consp backend) backend (list backend))
						'(:with company-yasnippet))))
(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
  #+end_src

*** academic-phrases

#+BEGIN_SRC emacs-lisp
(use-package academic-phrases
	:ensure t
)
#+END_SRC

** Syntax checking

*** flycheck

#+begin_src emacs-lisp
(use-package flycheck
	:ensure t
	:config
	(global-flycheck-mode t)
	(add-hook 'text-mode-hook '(lambda ()(flycheck-mode 0)))
	)
#+end_src

*** flycheck-plantuml

#+BEGIN_SRC emacs-lisp
(use-package flycheck-plantuml
  :ensure t
  :after (flycheck plantuml)
  :config (flycheck-plantuml-setup))
#+END_SRC

*** flycheck-vale

Flycheck integration for [[https://github.com/errata-ai/vale][vale]], a natural language linter.
=flycheck-vale= currently supports =text-mode=, =markdown-mode=, =rst-mode=, and =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package flycheck-vale
	:ensure t
	:after (flycheck)
	:config (flycheck-vale-setup))
#+END_SRC
** Spell checking

*** flyspell

#+begin_src emacs-lisp
(setq ispell-program-name "aspell")

;; remove keybindings for autocorrect 
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-;") nil))
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-.") nil))

;; ;; activate for text
;; (dolist (hook '(text-mode-hook LaTeX-mode-hook))
;; 	(add-hook hook (lambda () (flyspell-mode 1))))

(defun flyspell-toggle (arg)
	(interactive "p")
	(if (bound-and-true-p flyspell-mode)
			(progn
				 (flyspell-mode -1)
			)	 
		(progn
			(flyspell-buffer)
			(flyspell-mode)
			)))

;; move point to previous error
;; http://emacs.stackexchange.com/a/14912/2017
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))))))


(defun flyspell-next-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-next-error)
		(ispell-word)
		))

(defun flyspell-previous-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-previous-error)
		(ispell-word)
		))

(defun flyspell-goto-next-and-correct (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-next-error)
		(flyspell-correct-word-generic)
		(right-char)
		))

(defun flyspell-goto-previous-and-correct (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-previous-error 1)
		(flyspell-correct-word-generic)
		(left-word)
		))

#+end_src

Flyspell face:
#+BEGIN_SRC emacs-lisp
(face-spec-set 'flyspell-incorrect '((t (:inherit error))))
#+END_SRC

*** flyspell-correct

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct
	:ensure t
	:config
	(use-package flyspell-correct-helm
		:ensure t)
	;; (add-hook 'flyspell-mode-hook #'flyspell-correct-auto-mode)
	;; (setq flyspell-correct-auto-delay 0.8)
	)
#+END_SRC

*** COMMENT flyspell-popup

Deprecated. I instead use =flyspell-correct=.

#+BEGIN_SRC emacs-lisp
(use-package flyspell-popup
	:ensure t
	:defer t
	:init
	(progn
		(setq flyspell-popup-correct-delay 0.8)
		(add-hook 'flyspell-mode-hook 'flyspell-popup-auto-correct-mode))
	:config
	;; unset keys in popup-menu, so that flyspell-popup will close the popup when using them. 
	(define-key popup-menu-keymap (kbd "<right>") nil)
	(define-key popup-menu-keymap (kbd "<left>") nil)
	(define-key popup-menu-keymap (kbd "TAB") 'popup-select) ; Unfortunately, this does not seem to work.
)
#+END_SRC

** Grammar checking

[[flycheck-vale]]

*** emacs-langtool

Grammar checking with [[https://www.languagetool.org/][LanguageTool]].

#+BEGIN_SRC emacs-lisp
(use-package langtool
	:ensure t
	:config (setq langtool-language-tool-jar (expand-file-name (concat (getenv "WEMACS_LANGUAGETOOL_PATH") "/languagetool-commandline.jar"))))
#+END_SRC

** Paren handling

*** smartparens

Similar to [[embrace]].

#+begin_src emacs-lisp
(use-package smartparens
	:ensure t
	:config
	(use-package smartparens-config)
	(setq sp-autoescape-string-quote nil)
	(--each '(LaTeX-mode-hook
						R-mode-hook
						TeX-mode-hook
						bibtex-mode-hook
						css-mode-hook
						emacs-lisp-mode-hook
						java-mode-hook
						js-mode-hook
						markdown-mode-hook
						org-mode-hook
						perl-mode-hook
						plantuml-mode-hook
						python-mode-hook
						sh-mode-hook
						shell-mode-hook
						xmg-mode-hook
						web-mode-hook)
		(add-hook it #'smartparens-mode))
	(require 'smartparens-latex)
	(require 'smartparens-ess)
	;; for all modes
	(sp-pair "(" nil :unless '(sp-point-before-word-p))
	(sp-pair "[" nil :unless '(sp-point-before-word-p))
	(sp-pair "{" nil :unless '(sp-point-before-word-p))
	(sp-pair "\"" nil :unless '(sp-point-before-word-p))
	;; org-mode
	(sp-with-modes 'org-mode
		(sp-local-pair "*" "*"
									 ;; :actions '(insert wrap) ; Don't know what this is good for.
									 :unless '(sp-point-after-word-p sp-point-before-word-p sp-point-at-bol-p sp-in-math-p) )
		(sp-local-pair "_" "_" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
		(sp-local-pair "/" "/" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
		(sp-local-pair "~" "~" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
		(sp-local-pair "=" "=" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
		(sp-local-pair "+" "+" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p tl/sp-point-after-hash-p) )
		(sp-local-pair "$" "$" :unless '(sp-point-after-word-p sp-point-before-word-p) )
		(sp-local-pair "«" "»"))
	;; latex-mode
	(sp-local-pair 'latex-mode "$" nil :unless '(sp-point-before-word-p))
	)

(defun tl/sp-point-after-hash-p (id action context)
	"Return t if point is after a hash, nil otherwise.
	This predicate is only tested on \"insert\" action.
	Its definition follows the one of sp-point-after-word-p."
	(when (eq action 'insert)
		(sp--looking-back-p (concat "\\(#\\)" (regexp-quote id)))))

;; jump to matching paren
(defun goto-match-paren (arg)
	"Go to the matching  if on (){}[], similar to vi style of % "
	(interactive "p")
	;; first, check for "outside of bracket" positions expected by forward-sexp, etc.
	(cond ((looking-at "[\[\(\{]") (forward-sexp))
				((looking-back "[\]\)\}]" 1) (backward-sexp))
				;; now, try to succeed from inside of a bracket
				((looking-at "[\]\)\}]") (forward-char) (backward-sexp))
				((looking-back "[\[\(\{]" 1) (backward-char) (forward-sexp))
				(t nil)))
(global-set-key (kbd "C-M-m") 'goto-match-paren)
(global-set-key (kbd "M-(") 'sp-backward-sexp)
(global-set-key (kbd "M-)") 'sp-forward-sexp)
(global-set-key (kbd "M-m") 'goto-match-paren)
(global-set-key (kbd "M-[") 'sp-beginning-of-sexp)
(global-set-key (kbd "M-]") 'sp-end-of-sexp)
(global-set-key (kbd "M-DEL") nil)
(global-set-key (kbd "M-DEL M-[") 'sp-unwrap-sexp)
#+end_src

*** emacs-pairs

#+begin_src emacs-lisp
;; https://ebzzry.github.io/emacs-pairs.html
;; (defmacro def-pairs (pairs)
;;   `(progn
;;      ,@(loop for (key . val) in pairs
;;           collect
;;             `(defun ,(read (concat
;;                             "wrap-with-"
;;                             (prin1-to-string key)
;;                             "s"))
;;                  (&optional arg)
;;                (interactive "p")
;;                (sp-wrap-with-pair ,val)))))
;; (def-pairs ((paren        . "(")
;;             (bracket      . "[")
;;             (brace        . "{")
;;             (single-quote . "'")
;;             (double-quote . "\"")
;;             (back-quote   . "`")))
;; (global-set-key (kbd "C-[") 'wrap-with-brackets) ; TODO: find nice key bindings
;; (global-set-key (kbd "C-(") 'wrap-with-parens)
;; (global-set-key (kbd "C-{") 'wrap-with-braces)
#+end_src

*** TODO embrace
:LOGBOOK:
- State "TODO"       from              [2018-09-03 Mo 23:13]
:END:

- [ ] Still does not load correctly in =org-mode=. 

Add/Change/Delete pairs based on =expand-region=, similar to =evil-surround= and [[smartparens]].
https://github.com/cute-jumper/embrace.el

#+BEGIN_SRC emacs-lisp
(use-package embrace 
	:ensure t
	:bind
	(("C-( a" . embrace-add)
	 ("C-( d" . embrace-delete)
	 ("C-( c" . embrace-change))
	:config

	(defun tl/embrace-delete-* ()
		(interactive)
		(embrace--delete ?*))
	(defun tl/embrace-delete-/ ()
		(interactive)
		(embrace--delete ?/))
	(defun tl/embrace-delete-_ ()
		(interactive)
		(embrace--delete ?_))
	(defun tl/embrace-delete-+ ()
		(interactive)
		(embrace--delete ?+))
	(defun tl/embrace-delete-= ()
		(interactive)
		(embrace--delete ?=))
	(defun tl/embrace-delete-~ ()
		(interactive)
		(embrace--delete ?~))

	(defun tl/embrace-org-mode-hook ()
		"Mostly taken from embrace-org-mode-hook which is defined in embrace.el."
		(dolist (lst '((?= "=" . "=")
									 (?~ "~" . "~")
									 (?/ "/" . "/")
									 (?* "*" . "*")
									 (?_ "_" . "_")
									 (?+ "+" . "+")
									 (?k "@@html:<kbd>@@" . "@@html:</kbd>@@")
									 (?l "@@latex:" . "@@")))
			(embrace-add-pair (car lst) (cadr lst) (cddr lst)))
		(embrace-add-pair-regexp ?b "#\\+BEGIN_.*" "#\\+END_.*" 'embrace-with-org-block
														 (embrace-build-help "#+BEGIN_*" "#+END") t))

	;; (add-hook 'LaTeX-mode-hook 'embrace-LaTeX-mode-hook)
	;; (add-hook 'org-mode-hook 'embrace-org-mode-hook)
	(add-hook 'org-mode-hook 'tl/embrace-org-mode-hook))
#+END_SRC

** Indentation

Auto-indent when yanking
https://www.emacswiki.org/emacs/AutoIndentation

#+begin_src emacs-lisp
(dolist (command '(yank yank-pop))
	(eval `(defadvice ,command (after indent-region activate)
					 (and (not current-prefix-arg)
								(member major-mode '(emacs-lisp-mode lisp-mode
																										 clojure-mode    scheme-mode
																										 haskell-mode    ruby-mode
																										 rspec-mode      python-mode
																										 c-mode          c++-mode
																										 objc-mode       latex-mode
																										 plain-tex-mode))
								(let ((mark-even-if-inactive transient-mark-mode))
									(indent-region (region-beginning) (region-end) nil))))))
#+end_src

Shift/delete indentation at cursor position or region:
#+BEGIN_SRC emacs-lisp
;; shift-region is taken from http://stackoverflow.com/a/6918574/6452961
(defun shift-region (distance)
	"Shift the selected region right if distance is positive, left if negative"
  (let ((mark (mark)))
    (save-excursion
      (indent-rigidly (region-beginning) (region-end) distance)
      (push-mark mark t t)
      ;; Tell the command loop not to deactivate the mark
      ;; for transient mark mode
      (setq deactivate-mark nil))))

(defun tl/delete-indentation ()
  (interactive)
  (if (use-region-p)
			(shift-region -999)
		(indent-rigidly (line-beginning-position) (line-end-position) -999)
		))
#+END_SRC

*** aggressive-indent

=aggressive-indent-mode= is a minor mode that keeps your code always indented.
Not sure whether I want to auto-indent whole files ...

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :config
	(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
	(add-hook 'css-mode-hook #'aggressive-indent-mode)
  ;; (global-aggressive-indent-mode)
  ;; (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
  ;; (add-to-list 'aggressive-indent-excluded-modes 'sql-mode)
  ;; (add-to-list 'aggressive-indent-excluded-modes 'web-mode)
)
#+END_SRC

** Selection

*** TODO expand-region
:LOGBOOK:
- State "TODO"       from              [2017-12-06 Mi 19:01]
:END:

- [ ] add better support for AUCTeX

#+begin_src emacs-lisp
(use-package expand-region
	:ensure t
	:bind ("C-+" . er/expand-region)
	)
#+end_src

*** Mouse selection

Copy mouse selection to kill-ring:
#+begin_src emacs-lisp
;; (setq mouse-drag-copy-region t)
#+end_src

*** iedit

Edit regions with identical content in the same way simultaneously. 

#+BEGIN_SRC emacs-lisp
(use-package iedit
	:ensure t
)
#+END_SRC

** Code folding

*** hideshow

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure t
  :diminish hs-minor-mode
  :config
	(add-hook 'prog-mode-hook 'hs-minor-mode))
#+END_SRC

=hideshow-org= adds org-mode like folding experience to hideshow.

#+BEGIN_SRC emacs-lisp
(use-package hideshow-org
	:ensure t
  :config
	(add-hook 'prog-mode-hook 'hs-org/minor-mode))
#+END_SRC

** Context menu

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<mouse-3>") 'mouse-major-mode-menu)
(global-set-key (kbd "<C-down-mouse-3>") 'mouse-popup-menubar)
#+END_SRC

Org-mode has its own context menu:
#+BEGIN_SRC emacs-lisp
(require 'org-mouse)
#+END_SRC

*** COMMENT ctxmenu

Unfortunately, =ctxmenu= lets my Emacs crash.

#+BEGIN_SRC emacs-lisp
(use-package ctxmenu
	:ensure t
	:config
	(require 'ctxmenu-config)
	(ctxmenu-config:setup ctxmenu-config:extra-features)
	;; (setq ctxmenu-config:exclude-features '(window register))
	(define-key global-map [mouse-3] 'ctxmenu:show)
	)
#+END_SRC

*** discover

Maybe an option in the future. 

https://github.com/mickeynp/discover.el

*** lacarte

Menu completion at the keyboard

#+BEGIN_SRC emacs-lisp
(use-package lacarte
  :bind ("C-<f6>" . lacarte-execute-menu-command))
#+END_SRC

** Cursor actions

*** General

This is supposed to accelerate cursor movement (https://emacs.stackexchange.com/a/28746/12336):

#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC

*** ace-jump

#+begin_src emacs-lisp
(use-package ace-jump-mode
	:ensure t
	:bind 
	("C-c SPC" . ace-jump-mode))
#+end_src

*** TODO dump-jump

- [ ] adjust key bindings
- [ ] add LaTeX support

Jump to definition without using tags.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config (setq dumb-jump-selector 'helm)
)
#+END_SRC

*** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
	:ensure t
	:bind
	("C-S-c C-S-c" . mc/edit-lines)
	("C->" . mc/mark-next-like-this)
	("C-<" . mc/mark-previous-like-this)
	("C-c C-<" . mc/mark-all-like-this)
	)
#+end_src

*** point-undo

Cursor position history (LOCAL)

#+begin_src emacs-lisp
(require 'point-undo)
(global-set-key [M-left] 'point-undo)
(global-set-key [M-right] 'point-redo)
(global-set-key (kbd "M-j") 'point-undo)
(global-set-key (kbd "M-k") 'point-redo)
;; focus on line-based jumps
;; http://emacs.stackexchange.com/a/28078/12336
(defvar point-undo-ring-length 100)
(defvar point-undo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-undo-ring)
(defvar point-redo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-redo-ring)
(defun point-undo-pre-command-hook ()
  "Save positions before command."
  (unless (or (eq this-command 'point-undo)
              (eq this-command 'point-redo))
    (let ((line (line-number-at-pos)))
      (when (eq line (cdr (nth 0 (ring-elements point-undo-ring))))
        (ring-remove point-undo-ring 0))
      (ring-insert point-undo-ring (cons (point) line))
      (setq point-redo-ring (make-ring point-undo-ring-length)))))
(add-hook 'pre-command-hook 'point-undo-pre-command-hook)
(defun point-undo-doit (ring1 ring2)
  "ring1, ring2 = {point-undo-ring, point-redo-ring}"
  (condition-case nil
      (progn
        (goto-char (car (nth 0 (ring-elements ring1)))) 
        (ring-insert ring2 (ring-remove ring1 0)))
    (error nil)))
(defun point-undo ()
  "Undo position."
  (interactive)
  (point-undo-doit point-undo-ring point-redo-ring))
(defun point-redo ()
  "Redo position."
  (interactive)
  (when (or (eq last-command 'point-undo)
            (eq last-command 'point-redo))
    (point-undo-doit point-redo-ring point-undo-ring)))
#+end_src

*** goto-last-change

Cursor position undo history:

#+begin_src emacs-lisp
(use-package goto-last-change
	:ensure t
	:bind
	("M-_" . goto-last-change))
#+end_src

*** smarter C-a and C-e

Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

*** iregister

Helper functions to use the Emacs register interactively.

#+BEGIN_SRC emacs-lisp
(use-package iregister
	:ensure t)
#+END_SRC

** Images

#+BEGIN_SRC emacs-lisp
(use-package image+
	:ensure t
	:init
	(eval-after-load 'image '(require 'image+))
	:config
	(setq imagex-convert-command "magick")  ; "convert" does not work on Windows machines 
	)
#+END_SRC

** Undo & remove

*** undo-tree

Visualize the undo history.

#+begin_src emacs-lisp
(use-package undo-tree
	:ensure t
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+end_src

*** Remove newlines

- alternative: [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]]

http://stackoverflow.com/a/5194503
#+begin_src emacs-lisp
(defun remove-newlines-in-region ()
  "Removes all newlines in the region."
  (interactive)
  (save-restriction
    (narrow-to-region (point) (mark))
    (goto-char (point-min))
    (while (search-forward "\n" nil t) (replace-match " " nil t))))

(defun remove-newline ()
	(save-excursion 
		(search-forward "\n")
		(replace-match " ")))

(defun remove-newlines-or-blank-lines-dwim ()
	(interactive)
	(progn (if (use-region-p)
						 (remove-newlines-in-region)
					 (if (this-line-empty-p)
							 (delete-blank-lines)
						 (remove-newline)
					 ))))

(defun next-line-empty-p ()
  (save-excursion
		(next-line)
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun this-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))
#+end_src

*** Remove extra spaces

- alternative: [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]]

Remove extra spaces from line or region (TODO):
#+begin_src emacs-lisp
(defun tl/remove-extra-spaces-dwim ()
	"Remove extra spaces in line or in region."
	(interactive)
	(if (region-active-p)
			(save-restriction
				(narrow-to-region (point) (mark))
				(save-excursion 
					(goto-char (point-min))
					(while (re-search-forward "[ ]+" nil t) (replace-match " " nil t))))
		(save-excursion
			(move-beginning-of-line nil)  					; FIXME: undo doesn't see save-excursion
			(while (re-search-forward "[ ]+" (line-end-position) t)
				(replace-match " "))))
	)
#+end_src

*** Tracking changes

**** COMMENT highlight-changes-mode

FIXME: =highligh-changes-mode= is sometimes visible when loading buffers even though =highlight-changes-visibility-initial-state= is set to =nil=.

http://emacs-fu.blogspot.de/2009/05/tracking-changes.html

#+begin_src emacs-lisp
;; higlight changes in documents
(global-highlight-changes-mode t)
(setq highlight-changes-visibility-initial-state nil); initially hide; 

;; toggle visibility
;; (global-set-key (kbd "<f8>") 'highlight-changes-visible-mode) ;; changes

;; remove the change-highlight in region
;; (global-set-key (kbd "S-<f8>") 'highlight-changes-remove-highlight)

;; if you're not already using it for something else...
;; (global-set-key (kbd "<M-prior>") 'highlight-changes-next-change)
;; (global-set-key (kbd "<M-next>")  'highlight-changes-previous-change)

;; faces
(set-face-foreground 'highlight-changes nil)
(set-face-background 'highlight-changes "#916868")
(set-face-foreground 'highlight-changes-delete nil)
(set-face-background 'highlight-changes-delete "#916868")

;; http://stackoverflow.com/a/21084181/6452961
;; show mark in fringe
(eval-after-load "hilit-chg"
	'(progn
		 (defvar highlight-fringe-mark 'filled-square
			 "The fringe bitmap name marked at changed line.
	Should be selected from `fringe-bitmaps'.")

		 (defadvice hilit-chg-make-ov (after hilit-chg-add-fringe activate)
			 (mapc (lambda (ov)
							 (if (overlay-get ov 'hilit-chg)
									 (let ((fringe-anchor (make-string 1 ?x)))
										 (put-text-property 0 1 'display
																				(list 'left-fringe highlight-fringe-mark)
																				fringe-anchor)
										 (overlay-put ov 'before-string fringe-anchor))
								 ))
						 (overlays-at (ad-get-arg 1))))))
;; remove highlights on save time
(add-hook 'after-save-hook
					(lambda ()
						(when highlight-changes-mode
							(save-restriction
								(widen)
								(highlight-changes-remove-highlight (point-min) (point-max))))))
#+end_src

** Save, kill & yank

*** TODO easy-kill
:LOGBOOK:
- State "TODO"       from              [2018-11-09 Fri 19:00]
:END:

https://github.com/leoliu/easy-kill
https://emacsredux.com/blog/2018/11/09/an-easy-kill/

** Switch between buffers

Switching between buffers with C-tab:
#+begin_src emacs-lisp
  (use-package iflipb
    :ensure t
    :config
    (setq iflipb-wrap-around t)
    (setq iflipb-ignore-buffers "^ ")     ; include all buffers
    :bind
    ("<C-tab>" . iflipb-next-buffer))
#+end_src

** Narrowing

http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
	"Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
	(interactive "P")
	(declare (interactive-only))
	(cond ((and (buffer-narrowed-p) (not p)) (widen))
				((region-active-p)
				 (narrow-to-region (region-beginning)
													 (region-end)))
				((derived-mode-p 'org-mode)
				 ;; `org-edit-src-code' is not a real narrowing
				 ;; command. Remove this first conditional if
				 ;; you don't want it.
				 (cond ((ignore-errors (org-edit-src-code) t)
								(delete-other-windows))
							 ((ignore-errors (org-narrow-to-block) t))
							 (t (org-narrow-to-subtree))))
				((derived-mode-p 'latex-mode)
				 (LaTeX-narrow-to-environment))
				(t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only
;; copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (define-key LaTeX-mode-map "\C-xn"
              nil)))
#+end_src

** File browser
*** ranger, deer

Use deer instead plain directory listing:
#+begin_src emacs-lisp
(use-package ranger
	:ensure t
	:bind
	("C-x C-d" . deer))

;; open file from inside a buffer
(global-set-key (kbd "C-x f") 'find-file-at-point)
#+end_src

** Commenting

#+begin_src emacs-lisp
(global-set-key (kbd "C-;") 'comment-or-uncomment-region-or-line)
(eval-after-load "LaTeX-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(eval-after-load "markdown-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
				(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)
    (next-line)))
#+end_src

*** poporg

#+BEGIN_SRC emacs-lisp
(use-package poporg
	:ensure t
	:bind (("C-c '" . poporg-dwim))
	:config
	(define-key poporg-mode-map (kbd "C-c '") 'poporg-dwim))
#+END_SRC

*** Critical markup

#+begin_src emacs-lisp
(use-package cm-mode
	:ensure t
	:config
	(setq-default cm-author user-acronym))
#+end_src

** Line actions
*** Delete line
#+begin_src emacs-lisp
;; (global-set-key (kbd "C-d C-o") 'delete-blank-lines) ; not allowed here, see underi-mode.el
;; (global-set-key (kbd "C-d C-m") 'delete-blank-lines)
(global-set-key (kbd "C-S-k") 'kill-whole-line)
;; (global-set-key (kbd "C-k") 'kill-sentence) ; too greedy
(global-set-key (kbd "C-S-d") 'kill-whole-line)
#+end_src

Copy/cut whole line or region:
#+begin_src emacs-lisp
(global-set-key (kbd "C-w") 'xah-cut-line-or-region) ; cut
(global-set-key (kbd "M-w") 'xah-copy-line-or-region) ; copy
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))
(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2016-06-18"
  (interactive)
  (let (-p1 -p2)
    (if current-prefix-arg
        (setq -p1 (point-min) -p2 (point-max))
      (if (use-region-p)
          (setq -p1 (region-beginning) -p2 (region-end))
        (setq -p1 (line-beginning-position) -p2 (line-end-position))))
    (if (eq last-command this-command)
        (progn
          (progn ; hack. exit if there's no more next line
            (end-of-line)
            (forward-char)
            (backward-char))
          ;; (push-mark (point) "NOMSG" "ACTIVATE")
          (kill-append "\n" nil)
          (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
          (message "Line copy appended"))
      (progn
        (kill-ring-save -p1 -p2)
        (if current-prefix-arg
            (message "Buffer text copied")
          (message "Text copied"))))
		;; TL: commented out the following two lines. Cursor remains at region.
    ;; (end-of-line)   
    ;; (forward-char)
    ))
#+end_src

*** New line

#+begin_src emacs-lisp
(global-set-key (kbd "S-<return>") 'smart-open-line)
(global-set-key (kbd "C-x C-<return>") 'smart-open-line)
(global-set-key (kbd "C-S-<return>") 'smart-open-line-above)
(global-set-key (kbd "C-o") 'smart-open-line)
(global-set-key (kbd "C-S-o") 'smart-open-line-above)
;; http://emacsredux.com/blog/2013/03/26/smarter-open-line/
(defun smart-open-line ()
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
;; http://emacsredux.com/blog/2013/06/15/open-line-above/
(defun smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
#+end_src

*** Center line
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-l") 'recenter-top-bottom)
#+end_src

*** Move line

**** move-text

#+BEGIN_SRC emacs-lisp
(use-package move-text
	:ensure t
	:init
	(move-text-default-bindings)
	)
#+END_SRC

** Capitalization

Toggle letter case:
 #+begin_src emacs-lisp
(global-set-key (kbd "C-9") 'xah-toggle-letter-case) 
(defun xah-toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.

URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
Version 2016-01-08"
  (interactive)
  (let (
        (deactivate-mark nil)
        -p1 -p2)
    (if (use-region-p)
        (setq -p1 (region-beginning)
              -p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alnum:]")
        (setq -p1 (point))
        (skip-chars-forward "[:alnum:]")
        (setq -p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region -p1 -p2)
      (put this-command 'state 1))
     ((equal 1  (get this-command 'state))
      (upcase-region -p1 -p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region -p1 -p2)
      (put this-command 'state 0)))))
#+end_src

** Special characters

Insert special characters with [[*helm][helm]] based on =org-entities-help=.
Copied from https://github.com/jkitchin/scimax/blob/master/scimax-org.el.

#+BEGIN_SRC emacs-lisp
(defun helm-insert-org-entity ()
  "Helm interface to insert an entity from `org-entities'.
F1 inserts utf-8 character
F2 inserts entity code
F3 inserts LaTeX code (does not wrap in math-mode)
F4 inserts HTML code
F5 inserts the entity code."
  (interactive)
  (helm :sources
				(reverse
				 (let ((sources '())
							 toplevel
							 secondlevel)
					 (dolist (element (append
														 '("* User" "** User entities")
														 org-entities-user org-entities))
						 (when (and (stringp element)
												(s-starts-with? "* " element))
							 (setq toplevel element))
						 (when (and (stringp element)
												(s-starts-with? "** " element))
							 (setq secondlevel element)
							 (add-to-list
								'sources
								`((name . ,(concat
														toplevel
														(replace-regexp-in-string
														 "\\*\\*" " - " secondlevel)))
									(candidates . nil)
									(action . (("insert utf-8 char" . (lambda (x)
																											(mapc (lambda (candidate)
																															(insert (nth 6 candidate)))
																														(helm-marked-candidates))))
														 ("insert org entity" . (lambda (x)
																											(mapc (lambda (candidate)
																															(insert
																															 (concat "\\" (car candidate))))
																														(helm-marked-candidates))))
														 ("insert latex" . (lambda (x)
																								 (mapc (lambda (candidate)
																												 (insert (nth 1 candidate)))
																											 (helm-marked-candidates))))
														 ("insert html" . (lambda (x)
																								(mapc (lambda (candidate)
																												(insert (nth 3 candidate)))
																											(helm-marked-candidates))))
														 ("insert code" . (lambda (x)
																								(mapc (lambda (candidate)
																												(insert (format "%S" candidate)))
																											(helm-marked-candidates)))))))))
						 (when (and element (listp element))
							 (setf (cdr (assoc 'candidates (car sources)))
										 (append
											(cdr (assoc 'candidates (car sources)))
											(list (cons
														 (format "%10s %s" (nth 6 element) element)
														 element))))))
					 sources))))
(global-set-key (kbd "C-c i e") 'helm-insert-org-entity)
#+END_SRC

** Buffer actions

Open untitled new buffer:
#+begin_src emacs-lisp
(defun xah-new-empty-buffer ()
  "Open a new empty buffer.
URL `http://ergoemacs.org/emacs/emacs_new_empty_buffer.html'
Version 2015-06-12"
  (interactive)
  (let ((buf (generate-new-buffer "untitled")))
    (switch-to-buffer buf)
    (funcall (and initial-major-mode))
    (setq buffer-offer-save t)))
(global-set-key (kbd "<f7> <f7>") 'xah-new-empty-buffer)
#+end_src

Kill buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "M-<f4>") 'kill-this-buffer)
 #+end_src
 
Revert buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'revert-buffer)
 #+END_SRC

** Charmap

For showing the character map and letting one select a special symbol:

#+BEGIN_SRC emacs-lisp
(use-package charmap
	:ensure t)
#+END_SRC

** Thesauri
*** synosaurus

Thesaurus frontend for Emacs with pluggable backends:
- OpenThesaurus for German (online)
- WordNet for English (http://wordnet.princeton.edu/wordnet/download/current-version)

#+BEGIN_SRC emacs-lisp
(use-package synosaurus
	:ensure t
	:config
	(setq-default synosaurus-choose-method "default"
								synosaurus-backend 'synosaurus-backend-openthesaurus)
	)
#+END_SRC

*** powerthesaurus 

Uses [[https://www.powerthesaurus.org/][powerthesaurus.org]] for English.

#+BEGIN_SRC emacs-lisp
(use-package powerthesaurus
	:ensure t)
#+END_SRC

* Files

** org-agenda files

Should be loaded after [[Buffer]] settings in order to take effect.

Org-mode files are usually bundled within a single directory stored in the variable =org-directory=. But if there are links to org-mode files outside =org-directory=, they should be included to =org-agenda-files=, too.

#+BEGIN_SRC emacs-lisp
(defun tl/update-org-agenda-files ()
	(interactive)
	(require 'org-attach) ; in order not get disturbed by org-attach links
  (setq org-agenda-files ())
  (load-org-agenda-files-recursively (expand-file-name (concat org-directory "/"))) ; trailing slash required

	;; ;; The following code does not search the org directory recursively:
  ;; (setq org-agenda-files
	;; 			(append
	;; 			 (list org-directory)
	;; 			 (file-expand-wildcards (concat org-directory "/*/*.org"))))

	;; search for linked org-mode files within org-agenda-files and add them
	(save-current-buffer
		(dolist (file org-agenda-files)
			(find-file file)
			(add-links-to-org-agenda-files)   ; within the buffer of file
			))
	(switch-to-buffer (current-buffer))		; return to first buffer
	
	(customize-save-variable 'org-agenda-files org-agenda-files)
	(message "org-agenda-files updated")

	(org-id-update-id-locations)
	(message "org-id-files updated")	
	)
#+END_SRC

Search for org-mode files recursively:
#+BEGIN_SRC emacs-lisp
;; Modified http://stackoverflow.com/a/26548971/6452961
(require 'dash)
(defun load-org-agenda-files-recursively (dir) "Find all directories in DIR."
			 (unless (file-directory-p dir) (error "Not a directory `%s'" dir))
			 (unless (equal (directory-files dir nil org-agenda-file-regexp t) nil)
				 (setq org-agenda-files 
							 (append
								org-agenda-files
								(-filter 								; filter files with org-extension
								 (lambda (x) (not (string-match "#" x))) 
								 (file-expand-wildcards (concat dir "*.org"))))))
			 (dolist (file (directory-files dir nil nil t))
				 (unless (member file '("." ".."))
					 (let ((file (concat dir file "/")))
						 (when (file-directory-p file)
							 (load-org-agenda-files-recursively file)))))
			 )

;; set refile targets to move entries inside org-agenda 
(setq org-refile-targets '(
													 (nil :maxlevel . 2)             ; refile to headings in the current buffer
													 (org-agenda-files :maxlevel . 2) ; refile to any of these files
													 ))
#+END_SRC

Add linked org-mode files to =org-agenda-files=:
#+BEGIN_SRC emacs-lisp 
(defun add-links-to-org-agenda-files ()
	"Inspired by: http://stackoverflow.com/questions/38061773/add-linked-org-files-to-org-agenda-files"
	(interactive)
	(org-element-map  
			(org-element-parse-buffer)
			'link
		(lambda (x)
			(let ((org-link-path (org-element-property :path x))
						(org-link-type (org-element-property :type x)))
				(when (and (equal org-link-type "file") ; only links to files
									 (string-match-p "\\(^[a-z]:\\)\\|\\(~/\\)" "~/") ; relative paths are bad
									 (equal "org" (file-name-extension org-link-path)) ;only org-mode files
									 (file-exists-p org-link-path) ; only existing files
									 )
					(princ (concat " " org-link-path))
					(add-to-list 'org-agenda-files (expand-file-name org-link-path))
					)))))
#+END_SRC

Update =org-agenda-files= once a day during start-up.
#+BEGIN_SRC emacs-lisp
(defcustom org-agenda-files-last-update nil 
	"This variable saves the date of the last update of org-agenda-files.")
(when (not (string-equal org-agenda-files-last-update (format-time-string "%Y-%m-%d")))
	(tl/update-org-agenda-files)
	(customize-save-variable 'org-agenda-files-last-update (format-time-string "%Y-%m-%d"))
	(message "org-agenda-files-last-update updated"))
#+END_SRC

* Project management

** projectile

Project management based on Git repositories.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :commands (projectile-find-file 
						 projectile-switch-project) 
  :diminish projectile-mode
  :config
	(setq projectile-remember-window-configs t
				projectile-enable-caching t			  ; speed up projectile by caching index
				projectile-indexing-method 'alien ; use external commands like find, git etc. Maybe not supported in Windows.
				projectile-require-project-root t ; only use projectile in git projects
				projectile-keymap-prefix (kbd "C-x p") ; change keymap prefix
				projectile-switch-project-action 'projectile-dired ; use dired when switching projects
				)
  (projectile-global-mode))
#+END_SRC

Use helm for completions.

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
	:ensure t
	:bind (("C-x p o" . helm-projectile-find-file)
				 ("C-x p p" . helm-projectile-switch-project)
				 ("C-x p h" . helm-projectile)
				 ("C-x p g" . helm-projectile-grep)
				 ("C-x p s" . helm-projectile-grep))
	)
#+END_SRC

* underi-mode

Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 

Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html

#+BEGIN_SRC emacs-lisp
	(define-minor-mode underi-mode
		"Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 
	Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html"
		:lighter " ui"
		;; :global "t"
		:init-value t
		:keymap (let ((map (make-keymap)))
							
							(define-key input-decode-map (kbd "C-i") (kbd "H-i"))  ; to disentangle <tab> and C-i

							;; disentangle keys when using Emacs server
							;; local-function-key-map or input-decode-map are terminal-local
							(defun my-disentangled-keys (&optional frame)
								(with-selected-frame frame
									(define-key input-decode-map (kbd "C-i") (kbd "H-i"))  ; to disentangle <tab> and C-i
								))
							(add-hook 'after-make-frame-functions #'my-disentangled-keys)

							;; cursor keys
							(define-key key-translation-map (kbd "M-i") (kbd "<up>"))
							(define-key key-translation-map (kbd "M-k") (kbd "<down>"))
							(define-key key-translation-map (kbd "M-j") (kbd "<left>"))		
							(define-key key-translation-map (kbd "M-l") (kbd "<right>"))
							(define-key key-translation-map (kbd "M-I") (kbd "S-<up>"))
							(define-key key-translation-map (kbd "M-K") (kbd "S-<down>"))
							(define-key key-translation-map (kbd "M-J") (kbd "S-<left>"))		
							(define-key key-translation-map (kbd "M-L") (kbd "S-<right>"))

							;; more cursor keys
							(define-key map (kbd "M-n") 'scroll-up-command)
							(define-key map (kbd "M-p") 'scroll-down-command)
							(define-key map (kbd "C-M-n") '(lambda () (interactive) (scroll-up 3)))
							(define-key map (kbd "C-M-p") '(lambda () (interactive) (scroll-down 3)))
							(define-key map (kbd "M-o") 'point-redo)
							(define-key map (kbd "M-u") 'point-undo)
							(define-key map (kbd "M-z") 'goto-last-change)
							(define-key map (kbd "C-M-i") 'backward-paragraph)
							(define-key map (kbd "C-M-k") 'forward-paragraph)
							(define-key map (kbd "C-M-j") 'left-word)
							(define-key map (kbd "C-M-l") 'right-word)

							(define-key map (kbd "M-s-j")  'windmove-left)
							(define-key map (kbd "M-s-l") 'windmove-right)
							(define-key map (kbd "M-s-i")   'windmove-up)
							(define-key map (kbd "M-s-k")  'windmove-down)

							;; delete 
							(define-key map (kbd "C-d") nil)
							(define-key map (kbd "C-d C-k") 'kill-line)
							(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d <left>") 'delete-backward-char)
							(define-key map (kbd "C-d <right>") 'delete-forward-char)
							(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
							(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
							(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-o") 'delete-blank-lines)
							(define-key map (kbd "C-d C-m") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-<return>") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
							(define-key map (kbd "C-d C-e") 'kill-line)
							(define-key map (kbd "C-S-d") 'kill-whole-line)
							(define-key map (kbd "C-d SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d C-SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d TAB") 'tl/delete-indentation)
							(define-key map (kbd "C-d C-TAB") 'tl/delete-indentation)
							(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d )") 'sp-unwrap-sexp)

							;; LaTeX
							(define-key LaTeX-mode-map (kbd "C-d m") 'TeX-delete-macro)
							(define-key LaTeX-mode-map (kbd "C-d e") 'TeX-delete-environment)
							(define-key LaTeX-mode-map (kbd "C-d t") 'TeX-clean)

							;; return
							(define-key input-decode-map (kbd "C-m") (kbd "H-o")) ; to disentangle <return> and C-m
							(define-key key-translation-map (kbd "H-o") (kbd "RET"))
							(define-key map (kbd "C-S-m") 'smart-open-line)

 							;; org-mode
							(define-key org-mode-map (kbd "C-d r") 'org-babel-remove-result)
							(define-key org-mode-map (kbd "C-d f") 'embrace-delete) ; delete emphasis/font
							(define-key org-mode-map (kbd "C-d (") 'embrace-delete)
							(define-key org-mode-map (kbd "C-d *") 'tl/embrace-delete-*)
							(define-key org-mode-map (kbd "C-d /") 'tl/embrace-delete-/)
							(define-key org-mode-map (kbd "C-d +") 'tl/embrace-delete-+)
							(define-key org-mode-map (kbd "C-d _") 'tl/embrace-delete-_)
							(define-key org-mode-map (kbd "C-d =") 'tl/embrace-delete-=)
							(define-key org-mode-map (kbd "C-d ~") 'tl/embrace-delete-~) 
							(define-key org-mode-map (kbd "C-c f") 'embrace-add)
							(define-key org-mode-map (kbd "H-i") 'org-goto) ; otherwise helm-imenu will be used (FIXME)
 
							;; miscellaneous actions
							(define-key map (kbd "C-j") 'ace-jump-mode)
							(define-key map (kbd "C-S-j") 'ace-jump-line-mode)
							(define-key map (kbd "H-i") 'helm-imenu)
							(define-key map (kbd "C-S-i") 'imenu-list)

							map
							)
		(add-hook 'minibuffer-setup-hook 'underi-minibuffer)
		(with-eval-after-load 'org
			(define-key org-mode-map (kbd "C-d c") 'org-table-delete-column)
			(define-key org-mode-map (kbd "C-d C-c") 'org-table-delete-column)
			)
											
	)	
	;; TODO: make C-d switch to delete-mode?
	;; http://stackoverflow.com/a/12010437/6452961

	(defun tl/kill-forward-line (N)
		(interactive)
		(save-excursion
			(when (= (forward-line N) 0)
				(kill-whole-line))))

	(defun underi-minibuffer ()
		"Keymap for the minibuffer."
		(let ((map minibuffer-local-map))

			;; move cursor
			(define-key map (kbd "M-n") 'scroll-up-command)
			(define-key map (kbd "M-p") 'scroll-down-command)
			(define-key map (kbd "M-o") 'point-redo)
			(define-key map (kbd "M-u") 'point-undo)
			(define-key map (kbd "M-z") 'goto-last-change)
			(define-key map (kbd "C-M-i") 'backward-paragraph)
			(define-key map (kbd "C-M-k") 'forward-paragraph)
			(define-key map (kbd "C-M-j") 'left-word)
			(define-key map (kbd "C-M-l") 'right-word)

			;; delete 
			(define-key map (kbd "C-d") nil)
			(define-key map (kbd "C-d C-k") 'kill-line)
			(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d <left>") 'delete-backward-char)
			(define-key map (kbd "C-d <right>") 'delete-forward-char)
			(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
			(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
			(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
			(define-key map (kbd "C-S-d") 'kill-whole-line)
			(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d )") 'sp-unwrap-sexp)
			))

(define-key helm-map (kbd "H-i") 'helm-select-action) ; show actions (default is <tab>)

	;; (add-hook 'text-mode-hook 'underi-mode) ; superseded by :init-value t
	;; (add-hook 'prog-mode-hook 'underi-mode) ; superseded by :init-value t
#+END_SRC

* winkeys-mode

Key bindings roughly following the conventions of the Windows habitat.

#+BEGIN_SRC emacs-lisp
(define-minor-mode winkeys-mode
	"Key bindings roughly following the conventions of the Windows habitat."
	:init-value t
	:global t
	:lighter " wk"
	:keymap (let ((map (make-keymap)))
						
						;; save
						(define-key map (kbd "C-s") 'save-buffer)
						(define-key map (kbd "C-S-s") 'write-file)

						;; search and replace
						(define-key map (kbd "C-f") 'swiper-helm)
						;; (define-key map (kbd "C-f") 'swiper)
						;; (define-key map (kbd "C-f") 'helm-swoop)
						;; (define-key map (kbd "C-f") 'isearch-search)
						;; (define-key map (kbd "C-S-f a") 'helm-multi-swoop-all)
						;; (define-key map (kbd "C-S-f m") 'helm-multi-swoop-current-mode)
						;; (define-key map (kbd "C-S-f s") 'isearch-forward)
						;; (define-key map (kbd "C-S-f C-s") 'isearch-forward)
						;; (define-key map (kbd "C-S-f r") 'isearch-backward)
						;; (define-key map (kbd "C-S-f C-r") 'isearch-backward)
						(define-key map (kbd "C-r") 'query-replace)
						(define-key map (kbd "C-S-r") 'query-replace-regexp)
						(define-key map (kbd "C-o") 'helm-find-files)

						;; mark all
						(define-key map (kbd "C-x C-a") 'mark-whole-buffer)
						
						;; quit
						(define-key key-translation-map (kbd "M-q") (kbd "C-g"))

						;; undo/redo
						(define-key map (kbd "C-z") 'undo-tree-undo)
						(define-key map (kbd "C-S-z") 'undo-tree-redo)

						;; yank
						(define-key map (kbd "C-v") 'yank)						

						;; press ESC only once
						(define-key map (kbd "<escape>") 'keyboard-escape-quit)
						
						map
						)

	;; body 

	(add-hook 'minibuffer-setup-hook 'winkeys-minibuffer)

	(with-eval-after-load 'helm-swoop
		(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
		(define-key helm-swoop-map (kbd "C-f") 'tl/helm-swoop-C-s) 
		(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
		(define-key helm-multi-swoop-map (kbd "C-f") 'helm-next-line)
		(define-key helm-swoop-map (kbd "C-S-f a") 'helm-multi-swoop-all-from-helm-swoop)
		(define-key helm-swoop-map (kbd "C-S-f m") 'helm-multi-swoop-current-mode-from-helm-swoop)
		(define-key helm-swoop-map (kbd "M-a") 'helm-multi-swoop-all-from-helm-swoop))

	(with-eval-after-load 'swiper-helm
		(define-key swiper-helm-keymap (kbd "C-r") 'helm-previous-line)
		(define-key swiper-helm-keymap (kbd "C-f") 'tl/swiper-helm-C-s))

	(with-eval-after-load 'company
		(define-key company-active-map (kbd "C-s") 'save-buffer))

	;; ;; Maybe this is not needed any more 	
	;; (add-hook 'org-src-mode-hook
	;; 					(lambda ()((define-key (kbd "C-s") 'org-edit-src-save))))

;; (define-key key-translation-map (kbd "C-v") (kbd "C-y")) ; unfortunately this interferes with key chords using C-v
	)

(winkeys-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun winkeys-minibuffer ()
	"Keymap for the minibuffer."
	(let ((map minibuffer-local-map))

		;; undo/redo
		(define-key map (kbd "C-z") 'undo-tree-undo)
		(define-key map (kbd "C-S-z") 'undo-tree-redo)
		
		))
#+END_SRC

Let =helm-swoop= behave more like isearch:

#+BEGIN_SRC emacs-lisp
	;; FIXME: does not follow search hits; helm-action-follow-forward does not work here
	(defun tl/helm-swoop-C-s ()
		(interactive)
		(if (boundp 'helm-swoop-pattern)
				(if (equal helm-swoop-pattern "")
						(previous-history-element 1)
					(helm-next-line))
			(helm-next-line)
			))
#+END_SRC

TESTING: Let =swiper-helm= behave more like isearch:

#+BEGIN_SRC emacs-lisp
	(defun tl/swiper-helm-C-s ()
		(interactive)
		(if (boundp 'helm-pattern)
				(if (equal helm-pattern "")
						(previous-history-element 1)
					(helm-next-line))
			(helm-next-line)
			))
#+END_SRC

* TODO winkeys-starter-mode

https://github.com/publicus/emacs-org-mode-for-the-laity

* COMMENT sr-speedbar

#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
	:ensure t
	:bind
	("C-c C-k C-b" . sr-speedbar-toggle)
	:config
	(setq sr-speedbar-right-side nil)                          ; always on left side
	(add-hook 'speedbar-mode-hook '(lambda () (linum-mode 0))) ; disable linum for speedbar
	(setq speedbar-show-unknown-files t)                       ; show all files
	(setq sr-speedbar-width 30)                                ; default width
	)
#+END_SRC

* Windows and frames

Better keys for closing and switching between windows. The rest is done in [[*hydra-f2][hydra-f2]].

#+BEGIN_SRC emacs-lisp
	(global-set-key (kbd "M-s-<left>")  'windmove-left)
	(global-set-key (kbd "M-s-<right>") 'windmove-right)
	(global-set-key (kbd "M-s-<up>")   'windmove-up)
	(global-set-key (kbd "M-s-<down>")  'windmove-down)

	;; close window
	(global-set-key (kbd "M-<f2>") 'delete-window)
#+END_SRC


=winner-mode= allows you to undo (and redo) changes in the window configuration.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** COMMENT golden-ratio

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :init
  (golden-ratio-mode 1))
#+END_SRC

** transpose-frame

#+BEGIN_SRC emacs-lisp
(use-package transpose-frame
  :ensure t
  ;; :bind ("H-t" . transpose-frame)
)
#+END_SRC

** Navigation

Goto other window:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-s") 'other-window)
#+END_SRC

* Bookmarks

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat user-emacs-directory "bookmarks")) ; default bookmark file
(setq bookmark-save-flag 1) ; everytime bookmark is changed, automatically save it
(global-set-key (kbd "C-x C-r") 'helm-bookmarks)
#+END_SRC

* Git

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
	:ensure t
	:bind
	("C-x g" . magit-status)
	;; ("C-x C-g" . magit-status)
	:config
	;; show magit full screen
	(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
	)
#+end_src

** TODO COMMENT magit-gh-pulls

- [ ] "Error (use-package): magit-gh-pulls/:catch: Wrong number of arguments: (3 . 4), 2"

Show pull requests from Github in Magit.

#+BEGIN_SRC emacs-lisp
(use-package magit-gh-pulls             
  :ensure t
  :init (add-hook 'magit-mode-hook #'turn-on-magit-gh-pulls))
#+END_SRC

** TODO COMMENT magithub

- [X] Has to be properly configured.
- [ ] open issue: https://github.com/magit/magit/issues/3154

Enhancement of magit to make available a more comprehensive access to Github repositories, regarding issues etc.:

#+BEGIN_SRC emacs-lisp
(use-package magithub
	:ensure t
  :after magit
  :config
	(magithub-feature-autoinject t)
	(setq magithub-clone-default-directory "~/github"))
#+END_SRC

** git-gutter

#+begin_src emacs-lisp
(use-package git-gutter
	:ensure t
	:config
	(global-git-gutter-mode +1)
	;; (git-gutter:linum-setup) ; git-gutter is struggling with linum-mode
	(custom-set-variables
	 '(git-gutter:update-interval 2))
	:bind
	("C-x C-g" . nil)
	("C-x C-g TAB" . git-gutter:popup-hunk)
	("C-x C-g _" . git-gutter:revert-hunk)
	("C-x C-g z" . git-gutter:revert-hunk)
	("C-x C-g C-g" . git-gutter-mode)
	("C-x C-g g" . git-gutter-mode)
	("C-x C-g n" . git-gutter:next-hunk)
	("C-x C-g p" . git-gutter:previous-hunk)
	)
#+END_SRC

* Kill ring

#+BEGIN_SRC emacs-lisp
(defun xah-show-kill-ring ()
  "Insert all `kill-ring' content in a new buffer.

URL `http://ergoemacs.org/emacs/emacs_show_kill_ring.html'
Version 2017-06-19"
  (interactive)
  (let (($buf (generate-new-buffer "untitled")))
    (progn
      (switch-to-buffer $buf)
      (funcall 'fundamental-mode)
      (setq buffer-offer-save t)
      (dolist (x kill-ring )
        (insert x "\n--------------------------------------------------\n\n"))
      (goto-char (point-min)))))
#+END_SRC

* Shells

** better-shell

#+BEGIN_SRC emacs-lisp
(use-package better-shell
    :ensure t
    ;; :bind (("C-'" . better-shell-shell)
    ;;        ("C-;" . better-shell-remote-open))
		)
#+END_SRC

** Windows powershell

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
		(use-package powershell
			:ensure t)
)
(put 'upcase-region 'disabled nil)
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
					'(lambda () (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
(setq eshell-cmpl-dir-ignore "\`\\(CVS\\)/\\'") ; in order to complete `..` to `../`
(defun tl/eshell ()										; http://emacs.stackexchange.com/a/28603/12336
  (interactive)
  (eshell t))
(global-set-key (kbd "<f7> e") 'tl/eshell)
 #+END_SRC

** COMMENT WSL  bash

#+BEGIN_SRC emacs-lisp
(when (and (eq system-type 'windows-nt)
					 (executable-find "bash"))
	(setq explicit-shell-file-name "bash") 	; WSL bash
	(setq shell-file-name explicit-shell-file-name))
#+END_SRC

** Windows cmd

#+BEGIN_SRC emacs-lisp
(when (and 
			 (eq system-type 'windows-nt)
			 (executable-find "cmdproxy"))
	(setq explicit-shell-file-name "cmdproxy") 
	(setq shell-file-name explicit-shell-file-name)
	(setq shell-command-switch "-c")
	(setq w32-quote-process-args t))
#+END_SRC

* Encryption

https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources

Emacs uses =epa-file= by default. Everything should be set up and running already. 

GnuPG keyrings can be used for encrypting a file by adding 
#+BEGIN_EXAMPLE
-*- epa-file-encrypt-to: ("your@email.address") -*-
#+END_EXAMPLE 
to the top.

Look for authinfo file in =authinfo-directory=:
#+BEGIN_SRC emacs-lisp
(setq auth-sources
    (list (expand-file-name (concat authinfo-directory ".authinfo.gpg"))))
#+END_SRC

Function to look up password:
#+BEGIN_SRC emacs-lisp
;; Taken from https://github.com/jwiegley/dot-emacs/blob/master/init.el
(defun lookup-password (host user port)
  (require 'auth-source)
  (funcall (plist-get (car (auth-source-search :host host :user user
                                               :type 'netrc :port port))
                      :secret)))
#+END_SRC

* Process monitor

** proced

The built-in top-like process viewer in Emacs.

See https://www.masteringemacs.org/article/displaying-interacting-processes-proced or http://emacsredux.com/blog/2013/05/02/manage-processes-with-proced/

#+BEGIN_SRC emacs-lisp
(require 'proced)
(setq proced-auto-update-interval 1)

(defun proced-settings ()
  (proced-toggle-auto-update))
(add-hook 'proced-mode-hook 'proced-settings)

(global-set-key (kbd "C-x P") 'proced)
#+END_SRC

* Media player

** COMMENT emms

-[ ] For some reason, =emms= does not correctly use =vlc= under Windows.

#+BEGIN_SRC emacs-lisp
(use-package emms
  :ensure t :defer t
  :config
  (progn
		(require 'emms-setup)
		;; (emms-minimalistic) 
		(emms-all) 
		(emms-default-players)
		;; (setq emms-player-vlc-command-name
		;; 			(expand-file-name "path/to/vlc/binaries"))
		;; (setq emms-player-vlc-parameters '("--intf=rc")) 
    (setq emms-source-file-default-directory "~/Music/")
    (emms-add-directory-tree "~/Music/")))
#+END_SRC

* Tags

** etags

=etags= is part of Emacs.

** TODO COMMENT GLOBAL

- [X] install =mkid= (from =idutils=) >= v4.5)
- [ ] Still it does not work for ever language, e.g. elisp and latex.
  
[[http://savannah.gnu.org/projects/global/][GNU GLOBAL]] is a source code tagging system.

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :diminish ggtags-mode
  ;; :bind (("M-m T"   . ggtags-find-tag-regexp)
  ;;         ("M-m g t" . ggtags-create-tags)
  ;;         ("M-m g T" . ggtags-update-tags))
  ;; :init
  ;; (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
  :config
  (add-hook 'prog-mode-hook 'ggtags-mode))
#+END_SRC

* Chat

** COMMENT Jabber

- [ ] OMEMO support missing

#+BEGIN_SRC emacs-lisp
(use-package jabber
  :ensure t
  :defer t
  :config
  (setq jabber-chat-buffer-show-avatar nil
				jabber-vcard-avatars-retrieve nil
				jabber-alert-presence-hooks nil
				jabber-mode-line-mode t

				;; jabber-account-list ; better configure this in a secret place
				;;     '(("<your-gmail-email>"
				;;        (:network-server . "talk.google.com")
				;;        (:port . 443)
				;;        (:connection-type . ssl))))

))
#+END_SRC

* Web browsing

** atomic-chrome

Edit text areas of the browser in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package atomic-chrome
	:ensure t
	:config (atomic-chrome-start-server))
#+END_SRC

On the side of the browser, you need to install an extension such as [[https://github.com/GhostText/GhostText][GhostText]].

* bbdb

http://sachachua.com/notebook/emacs/bbdb-config.el

#+BEGIN_SRC emacs-lisp
  (use-package bbdb
    :ensure t
    :config (progn
              (bbdb-initialize)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-message)
                                          ;(add-hook 'message-setup-hook 'bbdb-define-all-aliases)

              (setq bbdb-file "~/Dropbox/bbdb"
                    bbdb-auto-revert t
                    bbdb-check-auto-save-file t
                    bbdb-expand-mail-aliases t
                    bbdb-phone-style nil
                    ;; bbdb-pop-up-window-size 10
                    bbdb-pop-up-target-lines 1 ; The window should be as small as possible
                    bbdb-use-pop-up nil        ; Show pup-up?

                                          ;bbdb/news-auto-create-p t
                    bbdb-complete-name-allow-cycling t
                    bbdb-complete-mail-allow-cycling t
                    bbdb-complete-name-full-completion t
                    bbdb-completion-type 'primary-or-name
                                          ;bbdb-use-pop-up nil

                    bbdb-offer-save 1  ; Always save
                    bbdb-electric-p t)
              ))

  (use-package bbdb-vcard
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-bbdb
    :ensure t)
  (global-set-key (kbd "<f7> a") 'helm-bbdb)
#+END_SRC

* Remote connections

** tramp

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (if (eq system-type 'windows-nt) 
      (progn
				(setq ange-ftp-ftp-program-name "ftp.exe")
				(setq tramp-default-method "plink"))
    (setq tramp-default-method "ssh"))
  ;; (setq tramp-default-user "")
#+END_SRC

** emacs-ssh-deploy

Deploy local files and directories to remote hosts.

https://github.com/cjohansson/emacs-ssh-deploy

* hydra

Nice examples:
https://github.com/rubensts/.emacs.d#hydra
https://github.com/jojojames/hydra-integrations

** hydra: begin

#+BEGIN_SRC emacs-lisp
	(use-package hydra
		:ensure t
		:config

#+END_SRC

** hydra-f1

- [ ] add =finder-commentary=

See also https://www.reddit.com/r/emacs/comments/3ba645/does_anybody_have_any_real_cool_hydras_to_share/cspqaly/

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f1 (:exit t :hint nil)

    "
    ╭────┐      
    │<f1>│  _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
    │Help│  Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭╯    └──^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^────╯

    Describe      ^^Keys                     ^^Elisp           ^^Documentation
    --------------^^-------------------------^^----------------^^---------------
    _m_ode          single _k_eybinding        _a_propros        _i_nfo
    _p_ackage       available _b_indings       _f_unction        _d_ocsets
    _c_ursor        _w_here is key             _v_ariable        _n_: man
    ^^              _y_asnippets

  "
    ;; Boring help commands...
    ("e" view-echo-area-messages "messages")
    ("l" view-lossage "lossage")
    ("C" describe-coding-system "coding system")
    ("I" describe-input-method "input method")

    ;; Documentation
    ("i" info nil)
    ("n" helm-man-woman nil)
    ("d" helm-dash nil)

    ;; Keybinds
    ("b" describe-bindings nil)
    ("c" describe-key-briefly nil)
    ("k" describe-key nil)
    ("w" where-is nil)
		("y" yas-describe-tables nil)

    ;; Elisp
    ("a" apropos-command nil)
    ("s" info-lookup-symbol nil)
    ("v" describe-variable nil)
    ("f" describe-function nil)
    ("S" describe-syntax nil)

    ;; Describe
    ("p" describe-package nil)
    ("m" describe-mode nil)
		("c" (what-cursor-position t) nil)

		("<f2>" hydra-f2/body :exit t)
		("<f3>" hydra-f3/body :exit t)
		("<f4>" hydra-f4/body :exit t)
		("<f5>" revert-buffer :exit t)
		("<f6>" hydra-f6/body :exit t)
		("<f7>" hydra-f7/body :exit t)
		("<f8>" hydra-f8/body :exit t)
		("<f9>" hydra-f9/body :exit t)
    ;; quit
    ("q" help-quit "quit"))

(global-set-key (kbd "<f1>") #'hydra-f1/body)
#+END_SRC

#+RESULTS:
: hydra-f1/body

** hydra-f2

#+BEGIN_SRC emacs-lisp
(require 'hydra-examples)								; provides hydra-move-splitter-left etc.
(defhydra hydra-f2
	(:hint nil
				 :idle 0.2)
	"
         ^^  ╭──────┐       
     _<f1>_  │<f2>  │  _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^  │Window│  Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^──╯      └────────^^────────^^──────────^^───^^───────^^───────^^───────^^────╯

          ^^  _<up>_            │→ _M-<right>_      [_z_] window undo    [_t_] transpose frame
          ^^   ↑   ^^           │split [_h_]oriz.   [_Z_] window redo    [_H_] swap horizontally
    _<left>_ ←   → _<right>_    │← _M-<left>_       [_f_] clone frame    [_V_] swap vertically
          ^^   ↓   ^^          ────────^^────────   [_b_] clone buffer      
          ^^ _<down>_           ↑ _M-<up>_             
          ^^ ^^                 split [_v_]ert.     [_=_] balance windows         [_q_]uit    
          ^^ ^^                 ↓ _M-<down>_
	"
	("<down>" windmove-down :exit t)
	("<up>" windmove-up :exit t)
	("<right>" windmove-right :exit t)
	("<left>" windmove-left :exit t) 
	("f" make-frame :exit t)
	("b" clone-indirect-buffer :exit t)
	("v" split-window-vertically :exit t)
	("h" split-window-horizontally :exit t)
	("M-<right>" hydra-move-splitter-right :exit nil)
	("M-<left>" hydra-move-splitter-left :exit nil)
	("M-<up>" hydra-move-splitter-up :exit nil)
	("M-<down>" hydra-move-splitter-down :exit nil)
	("=" balance-windows :exit t)
	("t" transpose-frame :exit t)
	("H" flop-frame :exit t)
	("V" flip-frame :exit t)
	("z" winner-undo)
	("Z" winner-redo)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f2>") 'hydra-f2/body)
#+END_SRC

** hydra-f3

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f3
		(:hint nil
					 :idle 0.2)
	"

         ^^   ^^         ╭──────┐       
     _<f1>_    _<f2>_    │<f3>  │  _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^    Window^^  │Config│  Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^───╯      └───────^^──────────^^───^^───────^^───────^^───────^^────╯
 
         [_i_] init file           [_p_] package manager      [_m_] macros
         [_d_] .emacs.d            [_u_] upgrade packages     [_fp_] proportional font
         [_c_] customize emacs     [_t_] load theme           
        [_lv_] visual line mode   [_ln_] line numbers         
        [_lt_] truncate lines     [_lr_] toggle relative line numbers        [_q_]uit
	"
	("i" (find-file (expand-file-name org-init-file user-emacs-directory)) :exit t)
	("d" (find-file user-emacs-directory) :exit t)
	("fp" toggle-proportional :exit t)
	("c" customize :exit t)
	("p" paradox-list-packages :exit t)
	("u" paradox-upgrade-packages :exit t)
	("m" hydra-macro/body :exit t)
	("t" hydra-load-theme/body :exit t)
	("ln" linum-mode :exit t)
	("lr" linum-relative-toggle :exit t)
	("lv" visual-line-mode :exit t)
	("lt" toggle-truncate-lines :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f3>") 'hydra-f3/body)
#+END_SRC

** hydra-f4

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f4
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^  ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_    │<f4> │  _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^  │Check│  Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^──╯     └─────────^^───^^───────^^───────^^───────^^─────╯
 
      [_e_] compilation errors      [_c_] code checking     [_s_] spell checking 
      [_#_] count words             [_r_] recover file                            [_q_]uit
	"
	("e" hydra-compilation-error/body :exit t)
	("c" hydra-flycheck/body :exit t)
	("r" recover-this-file :exit t)
	("s" hydra-flyspell/body :exit t)
	("#" count-words :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f4>") 'hydra-f4/body)
#+END_SRC

** hydra-f6

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f6>") 'hydra-f6/body)

(defun hydra-f6/body () ;hydra-for-major-mode ()
	(interactive)
  (cond
	 ((string-equal (buffer-mode) "deft-mode")
		(hydra-deft/body))
	 ((string-equal (buffer-mode) "dired-mode")
		(hydra-dired-main/body))
	 ((string-equal (buffer-mode) "elfeed-search-mode")
		(mz/make-and-run-elfeed-hydra))
	 ((string-equal (buffer-mode) "image-mode")
		(hydra-image/body))
	 ((string-equal (buffer-mode) "latex-mode")
		(hydra-latex-main/body))
	 ((string-equal (buffer-mode) "bibtex-mode")
		(hydra-bibtex/body))
	 ((string-equal (buffer-mode) "org-mode")
		(hydra-org-main/body))
	 ((string-equal (buffer-mode) "org-agenda-mode")
		(hydra-org-agenda/body))
	 ((string-equal (buffer-mode) "pomidor-mode")
		(hydra-pomidor/body))
	 ((string-equal (buffer-mode) "markdown-mode")
		(hydra-markdown/body))
	 ((or t) (message (concat "no hydra defined for major mode"))))
)
#+END_SRC

Function to look up the major mode of a buffer:
#+BEGIN_SRC emacs-lisp
(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
											(if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+END_SRC

Deprecated:

#+BEGIN_SRC 
(defvar hydra-f6-menu
	"
         ^^         ^^         ^^       ^^        ^^     ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_     │<f6>│  _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^  │Mode│  Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^──╯    └────^^─────────^^──────^^─╯
 
    ^^ _<f6>_: hydra for major mode ^^ ^^ ^^ ^^ ^^ ^^                         [_q_]uit
	"
)

	(defhydra hydra-f6-old
		(:hint nil
					 :idle 0.2)
(concat hydra-f6-menu) 
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-for-major-mode :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)
)
#+END_SRC

** hydra-f7

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f7
	(:hint nil
				 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_  │<f7>│  _<f8>_  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^  │Open│  Mark^^  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^──╯    └──────^^────────╯
 
       [_a_] adress book        [_d_] dired/file browser     [_t_] pomodoro timer
       [_b_] new buffer         [_e_] emacs shell            [_l_] dictionary
       [_i_] buffer overview    [_s_] system shell           [_B_] bookmarks
       [_c_] calendar          [_gs_] magit status          [_gl_] magit buffer log 
       [_p_] projectile         [_f_] search files          [_hb_] bibliography     
       [_P_] pandoc             [_r_] elfeed                              [_q_]uit
	" 
	("a" helm-bbdb :exit t)
	("c" my-open-calfw :exit t)
	("d" dired-jump :exit t)
	("f" hydra-search/body :exit t)
	("s" shell :exit t)
	("b" xah-new-empty-buffer :exit t)
	("hb" helm-bibtex :exit t)
	("i" ibuffer :exit t)
	("l" dictcc :exit t)
	("gs" magit-status :exit t)
	("gl" magit-log-buffer-file :exit t)
	("e" tl/eshell :exit t)
	("B" bookmark-bmenu-list :exit t)
	("p" helm-projectile :exit t)
	("P" pandoc-main-hydra/body :exit t)
	("r" tl/elfeed :exit t)
	("t" pomidor :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f7>") 'hydra-f7/body)
#+END_SRC

** hydra-f8

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f8
	(:hint nil
				 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^      ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_  │<f8> │  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^  │Mark │  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^──╯     └─────^^─╯

      [_a_] mark all                 [_g_] git gutter              [_p_] position register
      [_c_] highlight changes        [_w_] show/hide whitespaces   [_b_] add bookmark
      [_e_] edit same symbol         [_*_] critic markup           [_t_] tags
      [_s_] highlight same symbols   [_r_] mark rectangular               [_q_]uit
	"
	("a" mark-whole-buffer :exit t)
	("g" hydra-git-gutter/body :exit t)
	("c" hydra-highlight-changes/body :exit t)
	("r" rectangle-mark-mode :exit t)
	("b" bookmark-set :exit t)
	("e" iedit-mode :exit t)
  ("p" hydra-position-register/body :exit t)
	("s" hydra-highlight-symbol/body :exit t)
	("t" hydra-tags/body :exit t)
	("w" whitespace-mode :exit t)
  ("*" hydra-cm-mode/body :exit t )
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f9>" hydra-f9/body :exit t)

	)
	(global-set-key (kbd "<f8>") 'hydra-f8/body)
#+END_SRC

** hydra-f9

Global org-mode keys:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f9
	(:hint nil
				 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^       ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_  │<f9>│ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^  │Org │
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^──╯    ╵
 
     ^^  [_a_] agenda  ^^    [_n_] notes   ^^  ^^   ^^  ^^  ^^   [_r_] reload org       	
     ^^  [_d_] deft    ^^    [_t_] todos   ^^  ^^   ^^  ^^  ^^   [_u_] update agenda files
     ^^  [_c_] capture ^^    [_w_/_h_] work/home notes ^^  ^^[_C_] clocking...       
     ^^  [_f_] search  ^^    [_:_] tags ^^  ^^  ^^  ^^  ^^                      [_q_]uit

	"
	("a" org-agenda-list-complete :exit t)
	("d" deft :exit t)
	("n" (lambda nil (interactive)
				 (find-file (concat org-directory "/notes.org"))) :exit t)
	("o" deft :exit t)
	("c" org-capture :exit t)
	("C" hydra-org-clock/body :exit t)
	("t" org-todo-list :exit t)
	("w" (lambda nil (interactive)
				 (find-file (concat org-directory "/work/work.org"))) :exit t)
	("h" (lambda nil (interactive)
				 (find-file (concat org-directory "/home/home.org"))) :exit t)
	(":" org-tags-view :exit t)
	("r" org-reload :exit t)
	("f" helm-org-rifle-agenda-files :exit t)
	;; ("f" org-search-view :exit t)
	("s" org-search-view :exit t)
	("u" tl/update-org-agenda-files :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)

	)
(global-set-key (kbd "<f9>") 'hydra-f9/body)
#+END_SRC

** hydra-bibtex

#+BEGIN_SRC emacs-lisp
(defhydra hydra-bibtex (:hint nil :columns 4)
	"BibTeX mode"
	("o" bibtex-remove-OPT-or-ALT "remove OPT/ALT" :exit t)
	("c" bibtex-clean-entry "clean entry" :exit t)
	("f"  bibtex-make-field "new field" :exit t)
	("C-k"  bibtex-kill-field "kill field" :exit t)
	("k"  bibtex-kill-field "" :exit t)
	("C-w"  bibtex-kill-entry "kill entry" :exit t)
	("w"  bibtex-kill-entry "" :exit t)
	("y"  bibtex-yank "yank field" :exit t)
	("s"  bibtex-sort-buffer "sort entries" :exit t)
	("t"  tl/bibtex-add-timestamp "add timestamp" :exit t)
	;; ("+"  org-ref-bibtex-new-entry/body "new entry..." :exit t)
	;; ("+"  hydra-bibtex-langsci-new-entry/body "new entry..." :exit t)
	("+"  bibtex-entry "new entry..." :exit t)
	("i"  get-bibtex-from-doi "import from doi" :exit t)
	("h"  helm-bibtex "helm-bibtex" :exit t)
	("F"  org-ref-bibtex-file/body "file actions..." :exit t)
	("O"  org-ref-bibtex-hydra/body "org-ref hydra..." :exit t)
	("?" bibtex-print-help-message "help" :exit nil)
	("q" nil :color blue)
	)
#+END_SRC

*** COMMENT hydra-bibtex-langsci-new-entry

- Superseded by =bibtex-entry=.
- The hydra should be automatically generated depending on what entry templates are defined -- similarly to what is done here [[*elfeed][elfeed]]. 

#+BEGIN_SRC emacs-lisp
(defhydra hydra-bibtex-langsci-new-entry (:color blue :hint nil :columns 6)
  "New Bibtex entry"
  ("a" bibtex-Article "Article")
  ("b" bibtex-Book "Book")
  ("C" bibtex-Collection "Collection")
  ("c" bibtex-InCollection "InCollection")
  ("m" bibtex-Misc "Misc")
  ("o" bibtex-Online "Online")
  ("P" bibtex-Proceedings "Proceedings")
  ("p" bibtex-InProceedings "InProceedings")
  ("r" bibtex-TechReport "TechReport")
  ("t" bibtex-Thesis "Thesis")
  ("u" bibtex-Unpublished "Unpublished")
  ("q" nil "quit"))
#+END_SRC

** hydra-cm-mode

#+BEGIN_SRC emacs-lisp
(defhydra hydra-cm-mode
	(:body-pre (when (not (string-equal cm-mode "t"))
							 (font-lock-mode -1)
							 (font-lock-mode 1)
							 (cm-mode 1))
						 :hint nil)
			"
     CriticMarkup
   ╭──────────────╯
      [_<up>_] previous      [_a_] addition         [_i_] accept/reject
    [_<down>_] next          [_d_] deletion         [_I_] accept/reject all
     ^^                      [_s_] substitution
     [_F_] follow changes    [_c_] comment          [_q_]uit													
		 ^^											 ^^							  			[_Q_]uit and deactivate cm-mode
"
			("<up>" #'cm-backward-change)
			("<down>" #'cm-forward-change)
			("a" #'cm-addition :color blue)
			("d" #'cm-deletion :color blue)
			("s" #'cm-substitution :color blue)
			("c"#'cm-comment :color blue)
			("i" #'cm-accept/reject-change-at-point)
			("I" #'cm-accept/reject-all-changes)
			("t" #'cm-set-author)
			("F" #'cm-follow-changes :color blue)
			("q" nil :color blue)
			("Q" (cm-mode -1) :color blue))
(global-set-key (kbd "C-*") 'hydra-cm-mode/body)
#+END_SRC

** hydra-dired

https://gitlab.com/xuhdev/dired-quick-sort

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dired-main (:hint nil)
	"
 ^Navigation^            ^^            ^Mark^              ^Actions^             ^View^
-^----------^------------^^------------^----^--------------^-------^-------------^----^------------

             _<up>_      ^^             _m_: mark           _+_: new						  _g_: refresh              
  ^^            ʌ        ^^             _u_: unmark         _C_: copy to          _/_: filter 
  ^^                     ^^             _U_: unmark all     _D_: delete           _s_: sort		 
  _<left>_  ..     view  _<right>_      _t_: toggle mark    _R_: move to          _(_: details
  ^^               enter _RET_          _*_: specific       _r_: rename           _z_: size
  ^^                     ^^             ^^                  ^^
  ^^            v        ^^             _w_: copy file name _P_: change property
            _<down>_     ^^             _W_: copy path      _c_/_Z_: compress				  
  ^^                     ^^             ^^                  _=_: diff             _q_: quit dired     
   _._: home  _j_: jump  _f_: find        _$_: wdired         _e_: diff on marked   _Q_: quit hydra
                                                    
-^----------^------------------------^----^---------------^-------^-------------^----^-----------
"

	("<left>" (lambda () (interactive) (find-alternate-file "..")))
	("<up>" diredp-previous-line)
	("<down>" diredp-next-line)
	("RET" dired-find-file)
	("<right>" dired-view-file)
	("+" hydra-dired-new/body :color blue)
	("*" hydra-dired-mark/body :color blue)
	("P" hydra-dired-properties/body :color blue)
	("O" dired-do-chown)
	("M" dired-do-chmod)
	("G" dired-do-chgrp)
	("C" dired-do-copy)
	("D" dired-do-delete)
	("<delete>" dired-do-delete)
	("R" dired-do-rename)
	("S" dired-do-symlink)
	("Z" dired-do-compress)
	("c" dired-do-compress-to)
	("/" dired-narrow)
	("(" dired-hide-details-mode)
	("$" wdired-change-to-wdired-mode)
	("f" my-find-name-dired)
	("." (find-file home-directory))
	;; ("=" diredp-ediff)  ; FIXME: does not work under windows; does not find diff 
	("=" dired-diff)
	("e" ora-ediff-files)
	("g" revert-buffer)
	("j" dired-goto-file)
	("r" dired-efap)
	("s" dired-sort-toggle-or-edit)
	("m" dired-mark)
	("u" dired-unmark)
	("U" dired-unmark-all-marks)
	("t" dired-toggle-marks)
	("v" dired-view-file)
	("w" dired-copy-filename-as-kill)
	("W" tl/dired-copy-path-at-point)
	("z" dired-get-size)
	("q" quit-window :color blue)
	("Q" nil :color blue)
	)

(defhydra hydra-dired-new (:hint nil )
	"New"
	("d" dired-create-directory "directory"  :exit t :after-exit (hydra-dired-main/body))
	("f" find-file "file" :exit t)
	("s" dired-do-symlink "symbolic link" :exit t :after-exit (hydra-dired-main/body))
	("h" dired-do-hardlink "hard link" :exit t :after-exit (hydra-dired-main/body))
	("q" hydra-dired-main/body "quit" :color blue)
	)

(defhydra hydra-dired-mark (:hint nil :after-exit (hydra-dired-main/body))
	"Mark"
	("a" (dired-mark-files-regexp ".*") "all" :exit t)
	("d" dired-mark-directories "directories" :exit t)
	("." diredp-mark/unmark-extension "by extension" :exit t)
	("s" dired-mark-symlinks "symbolic links" :exit t)
	("r" dired-mark-files-regexp "by regexp" :exit t)
	("/" dired-mark-sexp "by search term" :exit t)
	("q" hydra-dired-main/body "quit" :exit t)
	)

(defhydra hydra-dired-properties (:hint nil :after-exit (hydra-dired-main/body))
	"Change"
	("o" dired-do-chown "owner")
	("r" dired-do-chmod "rights")
	("g" dired-do-chgrp "group")
	("q" hydra-dired-main/body "quit" :color blue)
	)
#+END_SRC

Don't ask for the path when searching for files:
#+BEGIN_SRC emacs-lisp
(defun my-find-name-dired (pattern)
  "My version of find-name-dired that always starts in my chosen folder"
  (interactive "sFind Name (file name wildcard): ")
  (dired-hide-details-mode)
  (find-name-dired "." pattern))
#+END_SRC

** hydra-org

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-main (:hint nil :columns 4)
	"Org-mode"
	("a" org-attach "attachments..." :exit t)
	("A" hydra-org-archive/body "archive..." :exit t)
	("b" org-tree-to-indirect-buffer "open in new buffer" :exit t)
	("C" hydra-org-columns/body "columns..." :exit t)
	("c" hydra-org-clock/body "clocking..." :exit t)
	("m" hydra-org-markup/body "markup..." :exit t)
	("n" org-add-note "add note" :exit t)
	("p" org-set-property "add property" :exit t)
	("P" org-set-property-and-value "add property-value pair" :exit t)
	("i" org-id-get-create "add ID" :exit t)
	("r" org-ref "org-ref" :exit t)
	("s" org-sort "sort" :exit t)
	("/" org-sparse-tree "filter" :exit t)
	("." tl/org-timestamp-dwim "timestamp" :exit t)
	("$" org-latex-fragment-toggle-toggle "show LaTeX" :exit t)
	("<tab>" org-show-current-heading-tidily "tidily unfold" :exit t)
	("t" org-todo "todo" :exit t)
	(":" org-set-tags "tags" :exit t)
	("+" org-priority-up "priority up" :exit nil)
	("-" org-priority-down "priority down" :exit nil)
	("*" org-cycle-list-bullet "cycle list type" :exit nil)
	("#" hydra-org-table/body "table..." :exit t)
	("\\" tl/org-toggle-overlays "toggle overlays" :exit t)
	("^" org-sort nil :exit t)
	("q" nil :color blue)
	)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun tl/org-toggle-overlays ()
	"Toggle the use of overlays that are used with links, emphasis markers, special symbols in the buffer."
	(interactive)
	(org-toggle-pretty-entities)
	(org-toggle-link-display)
	(if org-hide-emphasis-markers
			(setq org-hide-emphasis-markers nil)
		(setq org-hide-emphasis-markers t)
		)
	)
#+END_SRC

*** hydra-org-archive

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-archive (:hint nil)
	"Org-mode archive"
	("t" org-toggle-archive-tag "set archive tag" :exit t)
	("a" org-archive-to-archive-sibling "archive below" :exit t)
	("A" org-archive-subtree-default "archive outside" :exit t)
	("<tab>" org-force-cycle-archived "expand archive" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

*** hydra-org-columns

A hydra for org-columns.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-columns (:hint nil :color pink :columns 3 :body-pre (org-columns))
"Org-mode columns"
(">" org-columns-widen "widen")
("<" org-columns-narrow "narrow")
("a" org-columns-edit-allowed "allowed values" :exit t)
("c" org-columns-content "content" :exit t)
("e" org-columns-edit-value "edit" :exit t)
("n" org-columns-next-allowed-value "next allowed value")
("p" org-columns-previous-allowed-value "previous allowed value")
("r" org-columns-redo "refresh")
("s" org-columns-edit-attributes "select attribute")
("t" org-columns-todo "todo")
("M-S-<left>" org-columns-delete "delete")
("M-S-<right>" org-columns-new "new")
("M-<right>" org-columns-move-right "move right")
("M-<left>" org-columns-move-left "move left")
("<delete>" org-columns-delete)
("v" org-columns-show-value "show value")
("q" org-columns-quit :color blue)
)
#+END_SRC

*** hydra-org-clock

Hydra for clocking activities in org-mode (taken from https://github.com/abo-abo/hydra/wiki/Org-clock-and-timers):

#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" 'hydra-org-clock/body)
 (defhydra hydra-org-clock (:color blue :hint nil)
   "
^Clock:^ ^In/out^     ^Edit^   ^Summary^    | ^Timers:^ ^Run^           ^Insert
-^-^-----^-^----------^-^------^-^----------|--^-^------^-^-------------^------
(_?_)    _i_n         _e_dit   _g_oto entry | (_h_)     _b_egin         ti_m_e
 ^ ^     _c_ontinue   _Q_uit   _d_isplay    |  ^ ^      cou_n_tdown     i_t_em
 ^ ^     _o_ut        ^ ^      _r_eport     |  ^ ^      _p_ause toggle
 ^ ^     ^ ^          ^ ^      ^ ^          |  ^ ^      _s_top
"
   ("i" org-clock-in)
   ("c" org-clock-in-last)
   ("o" org-clock-out)
   
   ("e" org-clock-modify-effort-estimate)
   ("Q" org-clock-cancel)

   ("g" org-clock-goto)
   ("d" org-clock-display)
   ("r" org-clock-report)
   ("?" (org-info "Clocking commands"))

  ("b" org-timer-start)
  ("n" org-timer-set-timer)
  ("p" org-timer-pause-or-continue)
  ("s" org-timer-stop)

  ("m" org-timer)
  ("t" org-timer-item)
  ("h" (org-info "Timers")))
#+END_SRC

*** hydra-org-agenda

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-agenda (:hint nil :color pink :columns 4)
	"Org-agenda view"
	("+" org-agenda-priority-up "priority up" :exit nil)
	("-" org-agenda-priority-down "priority down" :exit nil)
	("d" org-agenda-day-view "day view" :exit nil)
	("w" org-agenda-week-view "week view" :exit nil)
	("h" org-agenda-holidays "holidays" :exit nil)
	("H" org-agenda-holidays "" :exit nil)
	("f" org-agenda-later "forward day/week/year" :exit nil)
	("b" org-agenda-earlier "backward day/week/year" :exit nil)
	("F" org-agenda-follow-mode "follow mode" :exit nil)
	("j" org-agenda-goto-date "jump to date" :exit nil)
	("J" org-agenda-clock-goto "clocked-in" :exit nil)
	("." org-agenda-goto-today "today" :exit nil)
	("k" org-agenda-kill "kill" :exit nil)
	("t" org-agenda-todo "todo keyword" :exit nil)
	("/" org-agenda-filter-by-tag "filter by tag" :exit nil)
	(":" org-agenda-set-tags "set tags" :exit nil)
	("r" org-agenda-redo "refresh" :exit nil)
	("q" nil :color blue)
	)
#+END_SRC

*** hydra-org-table

Taken from https://gist.github.com/dfeich/1df4e174d45f05fb5798ca514d28c68a and modified:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-table (:color pink :hint nil)
  "
org table helper
_r_ recalculate      _w_ wrap region    _c_ toggle coordinates
_i_ iterate table    _t_ transpose      _D_ toggle debugger
_B_ iterate buffer   _E_ export table   _?_ field info
_e_ eval formula     _s_ sort lines     _d_ edit field
_q_ quit
"
  ("E" org-table-export :color blue)
  ("s" org-table-sort-lines)
  ("d" org-table-edit-field)
  ("e" org-table-eval-formula)
  ("r" org-table-recalculate)
  ("i" org-table-iterate)
  ("B" org-table-iterate-buffer-tables)
  ("w" org-table-wrap-region)
  ("D" org-table-toggle-formula-debugger)
  ("t" org-table-transpose-table-at-point)
  ("?" org-table-field-info)
  ;; ("n" dfeich/org-table-remove-num-sep :color blue) ; _n_ remove number separators
  ("c" org-table-toggle-coordinate-overlays :color blue)
  ("q" nil :color blue))
#+END_SRC

*** hydra-org-markup

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-markup (:hint nil)
	"Org-mode markup"
	("b" (org-emphasize ?*) "bold" :exit t)
	("c" tl/insert-org-link-color "color" :exit t)
	("e" tl/insert-org-link-emph "emphasized" :exit t)
	("i" (org-emphasize ?/) "italic" :exit t)
	("m" tl/insert-org-link-mono "monospaced" :exit t)
	("s" tl/insert-org-link-smallcaps "small caps" :exit t)
	("t" tl/insert-org-link-term "term" :exit t)
	("u" (org-emphasize ?_) "underlined" :exit t)
	("x" tl/insert-org-link-example "example" :exit t)
	("d" afs/org-replace-link-by-link-description "delete markup" :exit t)
	("q" nil :color blue))
(global-set-key (kbd "C-c m") 'hydra-org-markup/body)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun tl/insert-org-link (type)
	(if (use-region-p)
			(let ((marked (buffer-substring (region-beginning) (region-end))))
				(progn
					(delete-region(region-beginning) (region-end))
					(insert (concat "[[" type "][" marked "]]"))))
		(insert (concat "[[" type "][]]"))
		(backward-char 2))) 
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun tl/insert-org-link-term ()
	(interactive)
	(tl/insert-org-link "term:"))

(defun tl/insert-org-link-smallcaps ()
	(interactive)
	(tl/insert-org-link "textsc:"))

(defun tl/insert-org-link-mono ()
	(interactive)
	(tl/insert-org-link "texttt:"))

(defun tl/insert-org-link-emph ()
	(interactive)
	(tl/insert-org-link "emph:"))

(defun tl/insert-org-link-example ()
	(interactive)
	(tl/insert-org-link "bsp:"))

(defun tl/insert-org-link-color ()
	(interactive)
	(tl/insert-org-link
	 (concat "color:"
					 (replace-regexp-in-string "[[:space:]]+" "" (helm-colors))))) 
#+END_SRC

Function to replace a link with its description, taken from https://emacs.stackexchange.com/a/21945/12336:
#+BEGIN_SRC emacs-lisp
(defun afs/org-replace-link-by-link-description ()
  "Replace an org link by its description or if empty its address"
  (interactive)
  (if (org-in-regexp org-bracket-link-regexp 1)
      (save-excursion
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3) 
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description)))))
#+END_SRC

** hydra-deft

#+BEGIN_SRC emacs-lisp
(defhydra hydra-deft (:hint nil :columns 3)
"Deft"
("a" deft-archive-file "archive" :exit t)
("d" deft-delete-file "delete" :exit t)
("k" deft-delete-file nil :exit t)
("f" deft-find-file "find" :exit t)
("g" deft-refresh "refresh" :exit t)
("n" deft-new-file "new" :exit t)
("r" deft-rename-file "rename" :exit t)
("l" deft-filter "filter" :exit t)
("/" deft-filter nil :exit t)
("Q" quit-window "quit" :exit t)
("q" nil :color blue)
)
#+END_SRC

** hydra-git-gutter

#+BEGIN_SRC emacs-lisp

		;; inspired by https://github.com/abo-abo/hydra/wiki/Git-gutter
		(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
																					:hint nil)
			"
     Git gutter
   ╭────────────╯
    [_j_] next hunk        [_s_]tage hunk     [_q_]uit
    [_k_] previous hunk    [_r_]evert hunk    [_Q_]uit and deactivate git-gutter
     ^ ^                   [_p_]opup hunk
    [_h_] first hunk
    [_l_] last hunk        set start [_R_]evision
	"
			("j" git-gutter:next-hunk)
			("k" git-gutter:previous-hunk)
			("h" (progn (goto-char (point-min))
									(git-gutter:next-hunk 1)))
			("l" (progn (goto-char (point-min))
									(git-gutter:previous-hunk 1)))
			("s" git-gutter:stage-hunk)
			("r" git-gutter:revert-hunk)
			("p" git-gutter:popup-hunk)
			("R" git-gutter:set-start-revision)
			("q" nil :color blue)
			("Q" (progn (git-gutter-mode -1)
									;; git-gutter-fringe doesn't seem to
									;; clear the markup right away
									(sit-for 0.1)
									(git-gutter:clear))
			 :color blue))
#+END_SRC

** hydra-ibuffer

Adapted hydra from https://github.com/abo-abo/hydra/wiki/Ibuffer:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^      ^Mark^          ^Actions^          ^View^
-^----------^------^----^----------^-------^----------^----^-------
   _<up>_:   ʌ     _m_: mark       _D_: delete        _g_: refresh
    _RET_: visit   _u_: unmark     _S_: save          _s_: sort
 _<down>_:   v     _*_: specific   _a_: all actions   _/_: filter
-^----------^---^----^----------^-------^----------^----^----------
"
  ("j" ibuffer-forward-line)
  ("<down>" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("<up>" ibuffer-backward-line)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" ibuffer-quit "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC

Automatically open the hydra with ibuffer:

#+BEGIN_SRC emacs-lisp
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
(global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

** hydra-image

#+BEGIN_SRC emacs-lisp
(defhydra hydra-image ()
	"Manipulate image"
	("+" imagex-sticky-zoom-in "zoom in")
	("-" imagex-sticky-zoom-out "zoom out")
	("m" imagex-sticky-maximize "maximize")
	("o" imagex-sticky-restore-original "original")
	;; ("S" imagex-sticky-save-image "save")
	("r" imagex-sticky-rotate-right "rotate right")
	("l" imagex-sticky-rotate-left "rotate left"))

#+END_SRC

** hydra-insert-date

Copied from https://github.com/cmcmahan/elisp/blob/master/emacs-hydra.el:

#+BEGIN_SRC emacs-lisp
(global-set-key
 (kbd "C-c d")
 (defhydra hydra-insert-date (:exit t :hint nil)
   "

      Insert Date
    ╭─────────────╯
      [_1_] 2017-09-30                            [_o_] org inactive stamp
      [_2_] 2017-09-30 Sa                         [_O_] org active stamp
      [_3_] 2017-09-30 Sa 23:35                   
      [_4_] September 30, 2017                    [_._] 30.09.2017
      [_5_] Saturday, September 30, 2017          [_/_] 30/09/2017  
      [_6_] 2017-09-30T23:47:53+02:00             
      ^^                                          [_q_] quit
   "
	 ("1" (insert-date "%Y-%m-%d"))
   ("2" (insert-date))
   ("3" (insert-date-time))
	 ("4" (insert-date "%B %d, %Y"))
	 ("5" (insert-date "%A, %B %d, %Y"))
	 ;; inspired from http://ergoemacs.org/emacs/elisp_insert-date-time.html
	 ("6" (insert (concat
								 (format-time-string "%Y-%m-%dT%T")
								 (funcall (lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")))))
   ("o" (insert-date "[%Y-%m-%d %a %k:%M]"))
   ("O" (insert-date "<%Y-%m-%d %a %k:%M>"))
	 ("/" (insert-date "%d/%m/%Y"))
   ("." (insert-date "%d.%m.%Y"))
   ("q" nil)))
(global-set-key (kbd "C-c i d") 'hydra-insert-date/body)
#+END_SRC

Copied from https://github.com/cmcmahan/elisp/blob/master/emacs-misc.el:

#+BEGIN_SRC emacs-lisp
(defvar insert-time-format "%k:%M"
  "*Format for \\[insert-time]. See `format-time-string' for info on how to format.")
(setq insert-time-format "%k:%M") ;; 08:09

(defvar insert-date-format "%Y-%m-%d"
  "*Format for \\[insert-date]. See `format-time-string' for info on how to format.")
(setq insert-date-format "%Y-%m-%d %a") ;; 2015-03-26 Thu

(defun insert-time (&optional time-format)
  "Insert the current time. Optional time format defaults to `insert-time-format'."
  (interactive "*")
  (let ((tformat (or time-format insert-time-format)))
    (insert (concat (format-time-string tformat (current-time)) " "))))

(defun insert-date (&optional date-format)
  "Insert the current date. Option format defaults to  `insert-date-format'."
  (interactive "*")
  (insert-time (or date-format insert-date-format)))

(defun insert-date-time ()
  "Insert the current date formatted with `insert-date-format',
then a space, then the current time formatted with
`insert-time-format'."
  (interactive "*")
  (insert-time
   (concat insert-date-format " " insert-time-format)))

(defun idt ()
  "Shortcut to `insert-date-time'"
(interactive)
(insert-date-time))

(defun mp-insert-date ()
  (interactive)
  (insert (format-time-string "%x")))
 
(defun mp-insert-time ()
  (interactive)
  (insert (format-time-string "%X")))
 
;; (global-set-key (kbd "C-c i d") 'mp-insert-date)
;; (global-set-key (kbd "C-c i t") 'mp-insert-time)

(defun insert-current-file-name ()
  (interactive)
  (insert (buffer-file-name (current-buffer))))
#+END_SRC

** hydra-insert-file-name

#+BEGIN_SRC emacs-lisp
(defhydra hydra-insert-file-name (:exit t :hint nil)
	"

      Insert File Name
    ╭──────────────────╯
      [_._] ../relative/path      [_w_] file namew
      [_/_] /absolute/path   
      ^^                                          [_q_] quit
   "
	("/" (insert (read-file-name "")))
	("." (insert (file-relative-name (read-file-name "") (file-name-directory (buffer-file-name)))))
  ("w" (insert (file-name-nondirectory (read-file-name ""))))
	("q" nil))
(global-set-key (kbd "C-c i f") 'hydra-insert-file-name/body)
#+END_SRC

** hydra-latex

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-main (:hint nil :columns 3)
	"LaTeX"
	("<up>" tl/reftex-previous "previous heading" :exit nil)
	("<down>" tl/reftex-next "next heading" :exit nil)
	("p" tl/reftex-previous :exit nil)
	("n" tl/reftex-next :exit nil)
	("=" reftex-toc "table of contents" :exit t)
	("d" hydra-latex-delete/body "delete..." :exit t)
	("f" hydra-latex-fonts/body "font..." :exit t)
	("b" reftex-create-bibtex-file  "generate bib-file" :exit t)
	("c" TeX-command-master "compile" :exit t)
	("l" TeX-recenter-output-buffer "show log" :exit t)
	("r" TeX-command-region "compile region" :exit t)
	("s" isearch-forward "search" :exit t)
	("o" hydra-latex-folding/body "folding..." :exit t)
	("v" TeX-view "view output" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for code folding with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-folding (:hint nil :body-pre (TeX-fold-mode 1))
	"LaTeX folding"
	("b" TeX-fold-clearout-buffer "remove folding in buffer" :exit t)
	("B" TeX-fold-buffer "activate folding in buffer" :exit t)
	("o" TeX-fold-dwim "fold dwim" :exit t)
	("Q" TeX-fold-mode "quit TeX-fold-mode" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for code deletion with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-delete (:hint nil)
	"LaTeX deletion"
	("f" TeX-deletefont "font" :exit t)
	("e" TeX-delete-environment "environment" :exit t)
	("m" TeX-delete-macro "macro" :exit t)
	("t" TeX-clean "temporary files" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for font selection with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-fonts (:hint nil :columns 3)
	"LaTeX fonts"
	("b" TeX-bold "bold" :exit t)
	("i" TeX-italic "italic" :exit t)
	("t" TeX-typewriter "typewriter" :exit t)
	("s" TeX-smallcaps "smallcaps" :exit t)
	("e" TeX-emphasis "emphasis" :exit t)
	("d" TeX-deletefont "delete" :exit t)
	("!b" TeX-bold-replace "replace with bold" :exit t)
	("!i" TeX-italic-replace "replace with italic" :exit t)
	("!t" TeX-typewriter-replace "replace with typewriter" :exit t)
	("!s" TeX-smallcaps-replace "replace with smallcaps" :exit t)
	("!e" TeX-emphasis-replace "replace with emphasis" :exit t)
	("q" nil :color blue)
	)
#+END_SRC
 
** hydra-markdown

#+BEGIN_SRC emacs-lisp
(defhydra hydra-markdown (:hint nil :columns 3)
	"Markdown"
	("b" markdown-insert-bold "bold" :exit t)
	("i" markdown-insert-italic "italic" :exit t)
	("s" markdown-insert-strike-through "strike through" :exit t)
	("l" markdown-insert-link "link" :exit t)
	(">" markdown-insert-blockquote "blockquote" :exit t)
	("`" markdown-insert-code "code" :exit t)
	("c" markdown-insert-gfm-code-block "code block" :exit t)
	("<righ>" markdown-demote "demote":exit nil)
	("<left>" markdown-promote "promote" :exit nil)
	("<up>" markdown-move-up "move up" :exit nil)
	("<down>" markdown-move-down "move down" :exit nil)
	("U" markdown-toc-generate-toc "generate TOC" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

** hydra-flycheck

#+BEGIN_SRC emacs-lisp
		;; inspired by https://github.com/abo-abo/hydra/wiki/Flycheck
		(defhydra hydra-flycheck
			(:pre (progn (setq hydra-lv t) (flycheck-mode +1) (flycheck-list-errors))
						:post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
						:hint nil)
"
  Errors
╭────────╯
"
			("f"  flycheck-error-list-set-filter                            "Filter")
			("j"  flycheck-next-error                                       nil)
			("<down>"  flycheck-next-error                                       "Next")
			("k"  flycheck-previous-error                                   nil)
			("<up>"  flycheck-previous-error                                   "Previous")
			("[" flycheck-first-error                                      "First")
			("]"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
			("Q"  (flycheck-mode -1) "Quit flycheck-mode") 
			("q"  nil))
#+END_SRC

** hydra-flyspell

#+BEGIN_SRC emacs-lisp
(defhydra hydra-flyspell (:pre (when (not flyspell-mode)
																 (flyspell-mode +1)
																 (flyspell-buffer))
															 :color blue
															 :hint nil
															 :idle 0.2)
    "
   ^^                            ^^                             ╭──────────┐
   ^^Flyspell                    ^^Ispell                       │ Flyspell │
╭──^^────────────────────────────^^─────────────────────────────┴──────────╯
    [_<up>_] previous error       [_b_] check buffer
       [_c_] correct word         [_w_] check word           
  [_<down>_] next error           [_d_] change dictionary   
       [_f_] toggle flyspell                             [_q_] quit window 
       [_p_] toggle prog mode                            [_Q_] quit flyspell
      "
    ("w" ispell-word :color red)
    ("i" ispell)
		("b" ispell-buffer)
    ("d" ispell-change-dictionary)
    ("f" flyspell-mode)
    ("p" flyspell-prog-mode)
    ;; ("c" flyspell-auto-correct-word)
		("c" flyspell-correct-word-generic)
    ;; ("<up>"  flyspell-previous-and-ispell-word :color red)
		;; ("<down>" flyspell-next-and-ispell-word :color red)
    ;; ("k"  flyspell-previous-and-ispell-word :color red)
		;; ("j" flyspell-next-and-ispell-word :color red)
    ("<up>"  flyspell-goto-previous-and-correct :color red)
		("<down>" flyspell-goto-next-and-correct :color red)
    ("k"  flyspell-goto-previous-and-correct :color red)
		("j" flyspell-goto-next-and-correct :color red)
    ("q" nil)
    ("Q" (flyspell-mode -1)))

#+END_SRC

** hydra-compilation-error

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/Compilation
(defhydra hydra-compilation-error (:hint nil :body-pre (hydra-compilation-error-body-pre))
	"
	    Compilation errors
    ╭────────────────────╯
	      [_<up>_] previous error   [_l_] list errors    [_q_]uit
	    [_<down>_] next error       
	"
	("`" hydra-compilation-error-next)
	("j" hydra-compilation-error-next)
	("<down>" hydra-compilation-error-next)
	("k" hydra-compilation-error-previous)
	("<up>" hydra-compilation-error-previous)
	("l" hydra-compilation-error-list :exit t)
	("o" hydra-compilation-error-list :exit t)
	("q" hydra-compilation-error-quit nil :color blue))

(defun hydra-compilation-error-next ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))

(defun hydra-compilation-error-previous ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-previous-error 1)))

(defun hydra-compilation-error-list ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-error-overview)))

(defun hydra-compilation-error-quit ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(delete-other-windows)))

(defun hydra-compilation-error-body-pre ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))
#+END_SRC

** hydra-multiple-cursors

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/multiple-cursors
(defhydra hydra-multiple-cursors (:hint nil :idle 0.2)
	"
    		 	 ^Up^                   ^Down^            ^Other^
   ╭───^^───────────────────────────────^^──────────────^^───────────────────╯
    [_S-<up>_] Next      [_S-<down>_] Next         [_l_] Edit lines
      [_<up>_] Skip        [_<down>_] Skip         [_a_] Mark all
    [_M-<up>_] Unmark    [_M-<down>_] Unmark       [_r_] Mark by regexp
           [_SPC_] Mark region ^^       ^^[C-S-<mouse1>] Mark with mouse    
        ^   ^              ^^                      [_q_] Quit hydra     [_Q_] Quit mc-mode
	"
	("l" mc/edit-lines :exit t)
	("a" mc/mark-all-like-this :exit t)
	("n" mc/mark-next-like-this)
	("N" mc/skip-to-next-like-this)
	("M-n" mc/unmark-next-like-this)
	("S-<down>" mc/mark-next-like-this)
	("<down>" mc/skip-to-next-like-this)
	("M-<down>" mc/unmark-next-like-this)
	("p" mc/mark-previous-like-this)
	("P" mc/skip-to-previous-like-this)
	("M-p" mc/unmark-previous-like-this)
	("SPC" set-rectangular-region-anchor :exit t)
	("S-<up>" mc/mark-previous-like-this)
	("<up>" mc/skip-to-previous-like-this)
	("M-<up>" mc/unmark-previous-like-this)
	("r" mc/mark-all-in-region-regexp :exit t)
  ("Q" (multiple-cursors-mode -1) :exit t)
	("q" nil))
(global-set-key (kbd "C-<") 'hydra-multiple-cursors/body)
(global-set-key (kbd "M-+") 'hydra-multiple-cursors/body)
(global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
  #+END_SRC

** hydra-highlight-changes

#+BEGIN_SRC emacs-lisp
(defhydra hydra-highlight-changes
	(:body-pre (highlight-changes-visible-mode +1)
						 :hint nil
						 :idle 0.5)
	"
    Highlight changes
  ╭───────────────────╯
	  _<up>_: next change       _q_uit
  _<down>_: previous change   _Q_uit and turn off highlighting 
	"
	("<down>" highlight-changes-next-change)
	("<up>" highlight-changes-previous-change)
	("<right>" highlight-changes-next-change)
	("<left>" highlight-changes-previous-change)
	("j" highlight-changes-next-change)
	("k" highlight-changes-previous-change)
	("n" highlight-changes-next-change)
	("p" highlight-changes-previous-change)
	("Q" (highlight-changes-visible-mode -1) :color blue)
	("q" nil :color blue))
#+END_SRC

** hydra-highlight-symbol

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-symbol
			(:pre (highlight-symbol-at-point) 
      :hint nil
			 :idle 0.5)
			"
   Highlight symbol
 ╭──────────────────╯
    _<up>_: previous occurrence    _r_: replace occurrences     _q_uit 
  _<down>_: next occurrence        
	"
			("<down>" highlight-symbol-next)
			("<up>" highlight-symbol-prev)
			("<right>" highlight-symbol-next)
			("<left>" highlight-symbol-prev)
			("j" highlight-symbol-next)
			("k" highlight-symbol-prev)
			("n" highlight-symbol-next)
			("p" highlight-symbol-prev)
			("c" highlight-symbol-count)
			("r" highlight-symbol-query-replace)
			("l" highlight-symbol-list-all)
			("q" highlight-symbol-remove-all :color blue))
#+END_SRC

** hydra-pomidor

#+BEGIN_SRC emacs-lisp
(defhydra hydra-pomidor (:color blue)
	"Pomidor"
	("<return>" pomidor-stop "next")
	("<space>" pomidor-break "pause")
	("R" pomidor-reset "reset")
	("q" quit-window "quit window")
	("Q" pomidor-quit "quit pomidor")
)
#+END_SRC

** hydra-position-register

#+BEGIN_SRC emacs-lisp
(defhydra hydra-position-register (:hint nil :columns 4)
	"Position register"
	("i" iregister-point-to-register "insert position" :exit t)
	("j" helm-register "jump to position" :exit t)
	("n" iregister-jump-to-next-marker "next position" :exit t)
	("p" iregister-jump-to-previous-marker "previous position" :exit t)
	("d" (lambda () (interactive) 
				 (setq register-alist '())
				 (message "Register is empty now.")) "clean register" :exit t)
	("q" nil :color blue))
#+END_SRC

** TODO COMMENT hydra-pdf-tools
:LOGBOOK:
- State "TODO"       from              [2018-01-27 Sa 15:40]
:END:

https://github.com/abo-abo/hydra/wiki/PDF-Tools

#+BEGIN_SRC emacs-lisp
(defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
         ^^_g_^^      _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
         ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline   [_i_] info
         ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
         ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link
    _h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
         ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
         ^^_n_^^      ^ ^  _r_eset slice box
         ^^^↓^^^
         ^^_G_^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-dark-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))
#+END_SRC

** hydra-load-theme

Switch between installed themes.

Copied from http://www.superloopy.io/articles/2017/hydra-theme-switcher.html:

#+BEGIN_SRC emacs-lisp
(defun sb/disable-all-themes ()
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(defun sb/load-theme (theme)
  "Enhance `load-theme' by first disabling enabled themes."
  (sb/disable-all-themes)
  (load-theme theme))

(setq sb/hydra-selectors
      "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defun sb/sort-themes (themes)
  (sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

(defun sb/hydra-load-theme-heads (themes)
  (mapcar* (lambda (a b)
             (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
           sb/hydra-selectors themes))

(bind-keys ("C-c w t" .
            (lambda ()
              (interactive)
              (call-interactively
               (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
                        "Select Theme"
                        ,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
                        ("DEL" (sb/disable-all-themes))
                        ("RET" nil "done" :color blue)))))))
#+END_SRC

I've added this to make it fit into [[*hydra-f3][hydra-f3]]:

#+BEGIN_SRC emacs-lisp
(defun hydra-load-theme/body ()
	(interactive)
	(call-interactively
	 (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
						"Select Theme"
						,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
						("DEL" (sb/disable-all-themes))
						("q" nil "quit" :color blue))))
)
#+END_SRC

** hydra-search

#+BEGIN_SRC emacs-lisp
(defhydra hydra-search (:color blue :columns 3)
  "Search"
	("a" helm-multi-swoop-all "all")
	("m" helm-multi-swoop-current-mode "same mode")
  ("g" helm-grep-do-git-grep "git grep")
  ("O" multi-occur "moccur")
  ("o" occur "occur")
  ("p" projectile-grep "project grep")
  ("r" isearch-backward "backwards")
	("s" isearch-forward "forward")
  ("f" isearch-forward nil)
	)
(global-set-key (kbd "C-S-f") 'hydra-search/body)
#+END_SRC

** hydra-tags

#+BEGIN_SRC emacs-lisp
(defhydra hydra-tags (:color red)
	"Tags"
	("." helm-etags-select "goto definition" :color blue)
	("q" nil "cancel" :color blue))
#+END_SRC

** hydra-transpose

Taken from https://github.com/abo-abo/hydra/wiki/Emacs

#+BEGIN_SRC emacs-lisp
(defhydra hydra-transpose (:color red)
	"Transpose"
	("c" transpose-chars "characters")
	("w" transpose-words "words")
	("x" transpose-sexps "expressions")
	("l" transpose-lines "lines")
	("s" transpose-sentences "sentences")
	("p" transpose-paragraphs "paragraphs")
	("f" transpose-frame "frame")
	("o" org-transpose-words "Org-words")
	("e" org-transpose-element "Org-elements")
	("tp" org-table-transpose-table-at-point "Org-table at point")
	("tc" hydra-org-table-move-cell/body "Org-table cell")
	("C-t" nil nil :color blue)
	("q" nil "cancel" :color blue))
(global-set-key (kbd "C-t") 'hydra-transpose/body)
#+END_SRC

** hydra-org-table-move-cell

Uses [[*Tables][org-table-move-single-cell]]:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-table-move-cell (:hint nil
																					 :idle 0.5)
	"
   Move org-table cell
 ╭─────────────────────╯
    _<up>_: move up       _<left>_: move left    
  _<down>_: move down    _<right>_: move left     _q_uit
	"
	("<up>" org-table-move-single-cell-up)
	("<down>" org-table-move-single-cell-down)
	("<right>" org-table-move-single-cell-right)
	("<left>" org-table-move-single-cell-left)
	("q" nil :color blue))
#+END_SRC

** TODO hydra-macro

Inspired by: https://github.com/abo-abo/hydra/wiki/Macro
#+BEGIN_SRC emacs-lisp
(defhydra hydra-macro (:hint nil :color pink :pre 
                             (when defining-kbd-macro
															 (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_i_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 _j_ ←   → _l_       [_o_] edit       [_a_] add       [_x_] register     
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_k_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("j" kmacro-start-macro :color blue)
  ("l" kmacro-end-or-call-macro-repeat)
  ("i" kmacro-cycle-ring-previous)
  ("k" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))
#+END_SRC

** hydra: end
  #+BEGIN_SRC emacs-lisp
		)                   
#+END_SRC
